const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const Database = require('../database/database');

// ƒê·ªãnh nghƒ©a c√°c boss v·ªõi th√¥ng tin chi ti·∫øt
const bosses = [
    {
        id: 1,
        name: 'Slime King',
        emoji: 'üëë',
        hp: 100,
        attack: 15,
        defense: 5,
        reward: { coins: 300, xp: 50 },
        rarity: 40
    },
    {
        id: 2,
        name: 'Fire Dragon',
        emoji: 'üê≤',
        hp: 200,
        attack: 25,
        defense: 10,
        reward: { coins: 600, xp: 100 },
        rarity: 25
    },
    {
        id: 3,
        name: 'Shadow Demon',
        emoji: 'üòà',
        hp: 150,
        attack: 30,
        defense: 8,
        reward: { coins: 500, xp: 80 },
        rarity: 20
    },
    {
        id: 4,
        name: 'Ice Giant',
        emoji: 'üßä',
        hp: 300,
        attack: 20,
        defense: 15,
        reward: { coins: 800, xp: 120 },
        rarity: 10
    },
    {
        id: 5,
        name: 'Ancient Golem',
        emoji: 'üóø',
        hp: 500,
        attack: 35,
        defense: 20,
        reward: { coins: 1500, xp: 200 },
        rarity: 5
    }
];

module.exports = {
    data: new SlashCommandBuilder()
        .setName('adventure')
        .setDescription('Tham gia phi√™u l∆∞u chi·∫øn ƒë·∫•u v·ªõi boss')
        .addStringOption(option =>
            option.setName('action')
                .setDescription('H√†nh ƒë·ªông trong phi√™u l∆∞u')
                .setRequired(false)
                .addChoices(
                    { name: '‚öîÔ∏è T√¨m Boss', value: 'fight' },
                    { name: 'üõ°Ô∏è Xem Equipment', value: 'gear' },
                    { name: 'üíä H·ªìi M√°u', value: 'heal' }
                )),

    async execute(interaction) {
        const userId = interaction.user.id;
        const username = interaction.user.username;
        const action = interaction.options.getString('action') || 'fight';

        await Database.createUser(userId, username);

        if (action === 'gear') {
            await this.showGear(interaction, userId);
        } else if (action === 'heal') {
            await this.healPlayer(interaction, userId);
        } else {
            await this.startBossFight(interaction, userId);
        }
    },

    async startBossFight(interaction, userId) {
        // L·∫•y th√¥ng tin player
        const player = await this.getPlayerStats(userId);
        
        // Random boss
        const boss = this.getRandomBoss();
        const playerHp = player.maxHp;
        const bossHp = boss.hp;

        const embed = new EmbedBuilder()
            .setTitle('‚öîÔ∏è Phi√™u l∆∞u Boss Fight!')
            .setDescription(`B·∫°n g·∫∑p **${boss.emoji} ${boss.name}**!`)
            .addFields(
                { name: 'üë§ Player Stats', value: `‚ù§Ô∏è HP: ${playerHp}/${player.maxHp}\n‚öîÔ∏è ATK: ${player.attack}\nüõ°Ô∏è DEF: ${player.defense}`, inline: true },
                { name: `${boss.emoji} Boss Stats`, value: `‚ù§Ô∏è HP: ${bossHp}/${boss.hp}\n‚öîÔ∏è ATK: ${boss.attack}\nüõ°Ô∏è DEF: ${boss.defense}`, inline: true },
                { name: 'üí∞ Ph·∫ßn th∆∞·ªüng', value: `${boss.reward.coins} coins\n${boss.reward.xp} XP`, inline: true }
            )
            .setColor('#ff6b35');

        const attackButton = new ButtonBuilder()
            .setCustomId('boss_attack')
            .setLabel('‚öîÔ∏è T·∫•n c√¥ng')
            .setStyle(ButtonStyle.Danger);

        const defendButton = new ButtonBuilder()
            .setCustomId('boss_defend')
            .setLabel('üõ°Ô∏è Ph√≤ng th·ªß')
            .setStyle(ButtonStyle.Secondary);

        const healButton = new ButtonBuilder()
            .setCustomId('boss_heal')
            .setLabel('üíä H·ªìi m√°u')
            .setStyle(ButtonStyle.Success);

        const row = new ActionRowBuilder().addComponents(attackButton, defendButton, healButton);

        await interaction.reply({
            embeds: [embed],
            components: [row]
        });

        // L∆∞u tr·∫°ng th√°i battle
        await this.saveBattleState(userId, {
            bossId: boss.id,
            playerHp: playerHp,
            bossHp: bossHp,
            turn: 1
        });

        // Collector cho battle
        const collector = interaction.channel.createMessageComponentCollector({
            filter: i => i.user.id === userId,
            time: 300000 // 5 ph√∫t
        });

        collector.on('collect', async (buttonInteraction) => {
            await this.handleBattleAction(buttonInteraction, userId);
        });
    },

    async handleBattleAction(interaction, userId) {
        const action = interaction.customId.split('_')[1];
        const battleState = await this.getBattleState(userId);
        
        if (!battleState) {
            return interaction.reply({ content: '‚ùå Kh√¥ng t√¨m th·∫•y tr·∫≠n chi·∫øn!', ephemeral: true });
        }

        const boss = bosses.find(b => b.id === battleState.bossId);
        const player = await this.getPlayerStats(userId);

        let playerDamage = 0;
        let bossDamage = 0;
        let playerHeal = 0;
        let actionText = '';

        // X·ª≠ l√Ω h√†nh ƒë·ªông c·ªßa player
        if (action === 'attack') {
            playerDamage = Math.max(1, player.attack - boss.defense + Math.floor(Math.random() * 10) - 5);
            actionText = `‚öîÔ∏è B·∫°n t·∫•n c√¥ng g√¢y ${playerDamage} damage!`;
        } else if (action === 'defend') {
            playerDamage = Math.max(1, Math.floor(player.attack * 0.7) - boss.defense);
            actionText = `üõ°Ô∏è B·∫°n ph√≤ng th·ªß v√† ph·∫£n c√¥ng g√¢y ${playerDamage} damage!`;
        } else if (action === 'heal') {
            playerHeal = Math.floor(player.maxHp * 0.3);
            actionText = `üíä B·∫°n h·ªìi ${playerHeal} HP!`;
        }

        // C·∫≠p nh·∫≠t HP boss
        battleState.bossHp = Math.max(0, battleState.bossHp - playerDamage);
        
        // C·∫≠p nh·∫≠t HP player (heal)
        battleState.playerHp = Math.min(player.maxHp, battleState.playerHp + playerHeal);

        // Boss t·∫•n c√¥ng (n·∫øu c√≤n s·ªëng v√† player kh√¥ng ph√≤ng th·ªß ho√†n to√†n)
        if (battleState.bossHp > 0) {
            const damageReduction = action === 'defend' ? 0.5 : 1;
            bossDamage = Math.max(1, Math.floor((boss.attack - player.defense) * damageReduction));
            battleState.playerHp = Math.max(0, battleState.playerHp - bossDamage);
        }

        battleState.turn++;

        // Ki·ªÉm tra k·∫øt th√∫c tr·∫≠n ƒë·∫•u
        if (battleState.bossHp <= 0) {
            // Player th·∫Øng
            await this.handleVictory(interaction, userId, boss);
            await this.deleteBattleState(userId);
            return;
        } else if (battleState.playerHp <= 0) {
            // Player thua
            await this.handleDefeat(interaction, userId, boss);
            await this.deleteBattleState(userId);
            return;
        }

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i battle
        await this.saveBattleState(userId, battleState);

        // T·∫°o embed c·∫≠p nh·∫≠t
        const embed = new EmbedBuilder()
            .setTitle(`‚öîÔ∏è Battle vs ${boss.emoji} ${boss.name} - Turn ${battleState.turn}`)
            .setDescription(`${actionText}\n${battleState.bossHp > 0 ? `${boss.emoji} ${boss.name} t·∫•n c√¥ng g√¢y ${bossDamage} damage!` : ''}`)
            .addFields(
                { name: 'üë§ Your HP', value: `‚ù§Ô∏è ${battleState.playerHp}/${player.maxHp}`, inline: true },
                { name: `${boss.emoji} Boss HP`, value: `‚ù§Ô∏è ${battleState.bossHp}/${boss.hp}`, inline: true }
            )
            .setColor(battleState.playerHp < player.maxHp * 0.3 ? '#ff0000' : '#ffaa00');

        const attackButton = new ButtonBuilder()
            .setCustomId('boss_attack')
            .setLabel('‚öîÔ∏è T·∫•n c√¥ng')
            .setStyle(ButtonStyle.Danger);

        const defendButton = new ButtonBuilder()
            .setCustomId('boss_defend')
            .setLabel('üõ°Ô∏è Ph√≤ng th·ªß')
            .setStyle(ButtonStyle.Secondary);

        const healButton = new ButtonBuilder()
            .setCustomId('boss_heal')
            .setLabel('üíä H·ªìi m√°u')
            .setStyle(ButtonStyle.Success);

        const row = new ActionRowBuilder().addComponents(attackButton, defendButton, healButton);

        await interaction.update({
            embeds: [embed],
            components: [row]
        });
    },

    async handleVictory(interaction, userId, boss) {
        await Database.updateUserBalance(userId, boss.reward.coins);
        await Database.updateUserXP(userId, boss.reward.xp);
        await Database.updateGameStats(userId, 'adventure', 'win');

        const embed = new EmbedBuilder()
            .setTitle('üéâ Chi·∫øn th·∫Øng!')
            .setDescription(`B·∫°n ƒë√£ ƒë√°nh b·∫°i **${boss.emoji} ${boss.name}**!`)
            .addFields(
                { name: 'üí∞ Ph·∫ßn th∆∞·ªüng', value: `${boss.reward.coins.toLocaleString()} coins`, inline: true },
                { name: '‚≠ê XP', value: `+${boss.reward.xp} XP`, inline: true }
            )
            .setColor('#00ff00')
            .setFooter({ text: 'S·ª≠ d·ª•ng /adventure ƒë·ªÉ ti·∫øp t·ª•c phi√™u l∆∞u!' });

        await interaction.update({
            embeds: [embed],
            components: []
        });
    },

    async handleDefeat(interaction, userId, boss) {
        await Database.updateGameStats(userId, 'adventure', 'lose');

        const embed = new EmbedBuilder()
            .setTitle('üíÄ Th·∫•t b·∫°i!')
            .setDescription(`B·∫°n ƒë√£ b·ªã **${boss.emoji} ${boss.name}** ƒë√°nh b·∫°i!`)
            .setColor('#ff0000')
            .setFooter({ text: 'H·ªìi m√°u v√† th·ª≠ l·∫°i v·ªõi /adventure heal!' });

        await interaction.update({
            embeds: [embed],
            components: []
        });
    },

    // Helper functions
    getRandomBoss() {
        const rand = Math.random() * 100;
        let cumulative = 0;
        
        for (const boss of bosses) {
            cumulative += boss.rarity;
            if (rand <= cumulative) {
                return boss;
            }
        }
        return bosses[0];
    },

    async getPlayerStats(userId) {
        const user = await Database.getUser(userId);
        const level = Math.floor(user.xp / 100) + 1;
        
        return {
            maxHp: 100 + (level * 10),
            attack: 20 + (level * 2),
            defense: 10 + level
        };
    },

    async saveBattleState(userId, state) {
        return new Promise((resolve, reject) => {
            Database.db.run(`
                INSERT OR REPLACE INTO battle_states (user_id, boss_id, player_hp, boss_hp, turn, created_at)
                VALUES (?, ?, ?, ?, ?, datetime('now'))
            `, [userId, state.bossId, state.playerHp, state.bossHp, state.turn], function(err) {
                if (err) reject(err);
                else resolve(this.lastID);
            });
        });
    },

    async getBattleState(userId) {
        return new Promise((resolve, reject) => {
            Database.db.get(
                'SELECT * FROM battle_states WHERE user_id = ?',
                [userId],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });
    },

    async deleteBattleState(userId) {
        return new Promise((resolve, reject) => {
            Database.db.run(
                'DELETE FROM battle_states WHERE user_id = ?',
                [userId],
                function(err) {
                    if (err) reject(err);
                    else resolve(this.changes);
                }
            );
        });
    },

    async showGear(interaction, userId) {
        const player = await this.getPlayerStats(userId);
        const user = await Database.getUser(userId);
        const level = Math.floor(user.xp / 100) + 1;

        const embed = new EmbedBuilder()
            .setTitle('üõ°Ô∏è Equipment & Stats')
            .setDescription(`Level ${level} Adventurer`)
            .addFields(
                { name: '‚ù§Ô∏è Health', value: `${player.maxHp} HP`, inline: true },
                { name: '‚öîÔ∏è Attack', value: `${player.attack} ATK`, inline: true },
                { name: 'üõ°Ô∏è Defense', value: `${player.defense} DEF`, inline: true }
            )
            .setColor('#9932cc')
            .setFooter({ text: 'Stats tƒÉng theo level! Ch∆°i game ƒë·ªÉ l√™n level.' });

        await interaction.reply({ embeds: [embed], ephemeral: true });
    },

    async healPlayer(interaction, userId) {
        const user = await Database.getUser(userId);
        const healCost = 100;

        if (user.balance < healCost) {
            return interaction.reply({ 
                content: `‚ùå B·∫°n c·∫ßn ${healCost} coins ƒë·ªÉ h·ªìi m√°u!`, 
                ephemeral: true 
            });
        }

        await Database.updateUserBalance(userId, -healCost);

        const embed = new EmbedBuilder()
            .setTitle('üíä H·ªìi m√°u th√†nh c√¥ng!')
            .setDescription('B·∫°n ƒë√£ h·ªìi ƒë·∫ßy m√°u v√† s·∫µn s√†ng chi·∫øn ƒë·∫•u!')
            .addFields(
                { name: 'üí∞ Chi ph√≠', value: `${healCost} coins`, inline: true },
                { name: '‚ù§Ô∏è Tr·∫°ng th√°i', value: 'M√°u ƒë·∫ßy 100%', inline: true }
            )
            .setColor('#00ff00');

        await interaction.reply({ embeds: [embed], ephemeral: true });
    }
};