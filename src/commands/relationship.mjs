import { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } from 'discord.js';
import User from '../models/User.mjs';
import Relationship from '../models/Relationship.mjs';
import { formatCurrency, successEmbed, errorEmbed } from './util.mjs';

export const data = new SlashCommandBuilder()
    .setName('relationship')
    .setDescription('H·ªá th·ªëng m·ªëi quan h·ªá x√£ h·ªôi')
    .addSubcommand(subcommand =>
        subcommand
            .setName('marry')
            .setDescription('C·∫ßu h√¥n ng∆∞·ªùi kh√°c')
            .addUserOption(option =>
                option.setName('user')
                    .setDescription('Ng∆∞·ªùi b·∫°n mu·ªën c·∫ßu h√¥n')
                    .setRequired(true))
            .addStringOption(option =>
                option.setName('message')
                    .setDescription('L·ªùi c·∫ßu h√¥n c·ªßa b·∫°n')
                    .setRequired(false)))
    .addSubcommand(subcommand =>
        subcommand
            .setName('befriend')
            .setDescription('K·∫øt b·∫°n v·ªõi ai ƒë√≥')
            .addUserOption(option =>
                option.setName('user')
                    .setDescription('Ng∆∞·ªùi b·∫°n mu·ªën k·∫øt b·∫°n')
                    .setRequired(true)))
    .addSubcommand(subcommand =>
        subcommand
            .setName('mentor')
            .setDescription('ƒê·ªÅ ngh·ªã l√†m mentor ho·∫∑c t√¨m mentor')
            .addUserOption(option =>
                option.setName('user')
                    .setDescription('Ng∆∞·ªùi b·∫°n mu·ªën l√†m mentor ho·∫∑c mentee')
                    .setRequired(true))
            .addStringOption(option =>
                option.setName('role')
                    .setDescription('B·∫°n mu·ªën l√†m g√¨?')
                    .setRequired(true)
                    .addChoices(
                        { name: 'T√¥i mu·ªën l√†m mentor', value: 'be_mentor' },
                        { name: 'T√¥i mu·ªën t√¨m mentor', value: 'find_mentor' }
                    )))
    .addSubcommand(subcommand =>
        subcommand
            .setName('rival')
            .setDescription('Th√°ch ƒë·∫•u ai ƒë√≥ l√†m ƒë·ªëi th·ªß')
            .addUserOption(option =>
                option.setName('user')
                    .setDescription('ƒê·ªëi th·ªß c·ªßa b·∫°n')
                    .setRequired(true)))
    .addSubcommand(subcommand =>
        subcommand
            .setName('status')
            .setDescription('Xem tr·∫°ng th√°i m·ªëi quan h·ªá')
            .addUserOption(option =>
                option.setName('user')
                    .setDescription('Ng∆∞·ªùi b·∫°n mu·ªën xem m·ªëi quan h·ªá')
                    .setRequired(false)))
    .addSubcommand(subcommand =>
        subcommand
            .setName('break')
            .setDescription('K·∫øt th√∫c m·ªëi quan h·ªá')
            .addUserOption(option =>
                option.setName('user')
                    .setDescription('Ng∆∞·ªùi b·∫°n mu·ªën k·∫øt th√∫c m·ªëi quan h·ªá')
                    .setRequired(true))
            .addStringOption(option =>
                option.setName('type')
                    .setDescription('Lo·∫°i m·ªëi quan h·ªá mu·ªën k·∫øt th√∫c')
                    .setRequired(true)
                    .addChoices(
                        { name: 'H√¥n nh√¢n', value: 'marriage' },
                        { name: 'B·∫°n b√®', value: 'friendship' },
                        { name: 'Mentor-Mentee', value: 'mentorship' },
                        { name: 'ƒê·ªëi th·ªß', value: 'rivalry' }
                    )))
    .addSubcommand(subcommand =>
        subcommand
            .setName('list')
            .setDescription('Xem danh s√°ch t·∫•t c·∫£ m·ªëi quan h·ªá c·ªßa b·∫°n'));

export async function execute(interaction) {
    const subcommand = interaction.options.getSubcommand();
    
    switch (subcommand) {
        case 'marry':
            await handleMarry(interaction);
            break;
        case 'befriend':
            await handleBefriend(interaction);
            break;
        case 'mentor':
            await handleMentor(interaction);
            break;
        case 'rival':
            await handleRival(interaction);
            break;
        case 'status':
            await handleStatus(interaction);
            break;
        case 'break':
            await handleBreak(interaction);
            break;
        case 'list':
            await handleList(interaction);
            break;
    }
}

async function handleMarry(interaction) {
    const targetUser = interaction.options.getUser('user');
    const message = interaction.options.getString('message') || 'B·∫°n c√≥ mu·ªën k·∫øt h√¥n v·ªõi t√¥i kh√¥ng? üíï';
    const userId = interaction.user.id;
    const guildId = interaction.guildId;
    
    if (targetUser.id === userId) {
        return interaction.reply({ 
            embeds: [errorEmbed('B·∫°n kh√¥ng th·ªÉ k·∫øt h√¥n v·ªõi ch√≠nh m√¨nh!')], 
            ephemeral: true 
        });
    }
    
    // Check if already married
    const existingMarriage = await Relationship.findOne({
        guildId,
        $or: [
            { user1Id: userId, user2Id: targetUser.id },
            { user1Id: targetUser.id, user2Id: userId }
        ],
        type: 'marriage',
        status: 'accepted'
    });
    
    if (existingMarriage) {
        return interaction.reply({ 
            embeds: [errorEmbed('M·ªôt trong hai ng∆∞·ªùi ƒë√£ k·∫øt h√¥n r·ªìi!')], 
            ephemeral: true 
        });
    }
    
    // Check for pending proposal
    const pendingProposal = await Relationship.findOne({
        guildId,
        $or: [
            { user1Id: userId, user2Id: targetUser.id },
            { user1Id: targetUser.id, user2Id: userId }
        ],
        type: 'marriage',
        status: 'pending'
    });
    
    if (pendingProposal) {
        return interaction.reply({ 
            embeds: [errorEmbed('ƒê√£ c√≥ l·ªùi c·∫ßu h√¥n ƒëang ch·ªù ph·∫£n h·ªìi!')], 
            ephemeral: true 
        });
    }
    
    // Create proposal
    const proposal = await Relationship.create({
        guildId,
        user1Id: userId,
        user2Id: targetUser.id,
        type: 'marriage',
        status: 'pending',
        proposalMessage: message
    });
    
    const embed = new EmbedBuilder()
        .setColor('#ff69b4')
        .setTitle('üíï L·ªùi C·∫ßu H√¥n')
        .setDescription(`<@${userId}> ƒë√£ c·∫ßu h√¥n <@${targetUser.id}>!`)
        .addFields(
            { name: 'üíå L·ªùi nh·∫Øn', value: message, inline: false },
            { name: 'üíç Chi ph√≠', value: 'Mi·ªÖn ph√≠ (t√¨nh y√™u v√¥ gi√°!)', inline: true }
        )
        .setFooter({ text: `${targetUser.username} c√≥ th·ªÉ ch·∫•p nh·∫≠n ho·∫∑c t·ª´ ch·ªëi` })
        .setTimestamp();

    const acceptButton = new ButtonBuilder()
        .setCustomId(`marry_accept_${proposal._id}`)
        .setLabel('üíï Ch·∫•p Nh·∫≠n')
        .setStyle(ButtonStyle.Success);

    const declineButton = new ButtonBuilder()
        .setCustomId(`marry_decline_${proposal._id}`)
        .setLabel('üíî T·ª´ Ch·ªëi')
        .setStyle(ButtonStyle.Danger);

    const row = new ActionRowBuilder().addComponents(acceptButton, declineButton);
    
    await interaction.reply({ embeds: [embed], components: [row] });
}

async function handleBefriend(interaction) {
    const targetUser = interaction.options.getUser('user');
    const userId = interaction.user.id;
    const guildId = interaction.guildId;
    
    if (targetUser.id === userId) {
        return interaction.reply({ 
            embeds: [errorEmbed('B·∫°n kh√¥ng th·ªÉ k·∫øt b·∫°n v·ªõi ch√≠nh m√¨nh!')], 
            ephemeral: true 
        });
    }
    
    // Check existing friendship
    const existingFriend = await Relationship.findOne({
        guildId,
        $or: [
            { user1Id: userId, user2Id: targetUser.id },
            { user1Id: targetUser.id, user2Id: userId }
        ],
        type: 'friendship',
        status: { $in: ['accepted', 'pending'] }
    });
    
    if (existingFriend) {
        if (existingFriend.status === 'accepted') {
            return interaction.reply({ 
                embeds: [errorEmbed('C√°c b·∫°n ƒë√£ l√† b·∫°n b√® r·ªìi!')], 
                ephemeral: true 
            });
        } else {
            return interaction.reply({ 
                embeds: [errorEmbed('ƒê√£ c√≥ l·ªùi m·ªùi k·∫øt b·∫°n ƒëang ch·ªù!')], 
                ephemeral: true 
            });
        }
    }
    
    // Create friendship request
    const friendship = await Relationship.create({
        guildId,
        user1Id: userId,
        user2Id: targetUser.id,
        type: 'friendship',
        status: 'pending'
    });
    
    const embed = new EmbedBuilder()
        .setColor('#48dbfb')
        .setTitle('ü§ù L·ªùi M·ªùi K·∫øt B·∫°n')
        .setDescription(`<@${userId}> mu·ªën k·∫øt b·∫°n v·ªõi <@${targetUser.id}>!`)
        .addFields(
            { name: 'üéÅ Bonus b·∫°n b√®', value: '+5% xu khi c√πng ho·∫°t ƒë·ªông', inline: true },
            { name: 'üéÆ Ho·∫°t ƒë·ªông chung', value: 'Unlocks friend activities', inline: true }
        )
        .setFooter({ text: `${targetUser.username} c√≥ th·ªÉ ch·∫•p nh·∫≠n ho·∫∑c t·ª´ ch·ªëi` })
        .setTimestamp();

    const acceptButton = new ButtonBuilder()
        .setCustomId(`friend_accept_${friendship._id}`)
        .setLabel('ü§ù K·∫øt B·∫°n')
        .setStyle(ButtonStyle.Success);

    const declineButton = new ButtonBuilder()
        .setCustomId(`friend_decline_${friendship._id}`)
        .setLabel('‚ùå T·ª´ Ch·ªëi')
        .setStyle(ButtonStyle.Secondary);

    const row = new ActionRowBuilder().addComponents(acceptButton, declineButton);
    
    await interaction.reply({ embeds: [embed], components: [row] });
}

async function handleMentor(interaction) {
    const targetUser = interaction.options.getUser('user');
    const role = interaction.options.getString('role');
    const userId = interaction.user.id;
    const guildId = interaction.guildId;
    
    if (targetUser.id === userId) {
        return interaction.reply({ 
            embeds: [errorEmbed('B·∫°n kh√¥ng th·ªÉ t·ª± mentor ch√≠nh m√¨nh!')], 
            ephemeral: true 
        });
    }
    
    const mentorId = role === 'be_mentor' ? userId : targetUser.id;
    const menteeId = role === 'be_mentor' ? targetUser.id : userId;
    
    // Create mentorship
    const mentorship = await Relationship.create({
        guildId,
        user1Id: userId,
        user2Id: targetUser.id,
        type: 'mentorship',
        status: 'pending',
        mentorId,
        menteeId
    });
    
    const embed = new EmbedBuilder()
        .setColor('#feca57')
        .setTitle('üéì ƒê·ªÅ Ngh·ªã Mentorship')
        .setDescription(role === 'be_mentor' 
            ? `<@${userId}> mu·ªën l√†m mentor cho <@${targetUser.id}>!`
            : `<@${userId}> mu·ªën <@${targetUser.id}> l√†m mentor!`)
        .addFields(
            { name: 'üìö L·ª£i √≠ch Mentor', value: '+10% xu t·ª´ mentee success', inline: true },
            { name: 'üéØ L·ª£i √≠ch Mentee', value: '+15% XP v√† gi·∫£m 50% fishing cost', inline: true }
        )
        .setFooter({ text: `${targetUser.username} c√≥ th·ªÉ ch·∫•p nh·∫≠n ho·∫∑c t·ª´ ch·ªëi` })
        .setTimestamp();

    const acceptButton = new ButtonBuilder()
        .setCustomId(`mentor_accept_${mentorship._id}`)
        .setLabel('üìö Ch·∫•p Nh·∫≠n')
        .setStyle(ButtonStyle.Success);

    const declineButton = new ButtonBuilder()
        .setCustomId(`mentor_decline_${mentorship._id}`)
        .setLabel('‚ùå T·ª´ Ch·ªëi')
        .setStyle(ButtonStyle.Danger);

    const row = new ActionRowBuilder().addComponents(acceptButton, declineButton);
    
    await interaction.reply({ embeds: [embed], components: [row] });
}

async function handleRival(interaction) {
    const targetUser = interaction.options.getUser('user');
    const userId = interaction.user.id;
    const guildId = interaction.guildId;
    
    if (targetUser.id === userId) {
        return interaction.reply({ 
            embeds: [errorEmbed('B·∫°n kh√¥ng th·ªÉ t·ª± th√°ch ƒë·∫•u ch√≠nh m√¨nh!')], 
            ephemeral: true 
        });
    }
    
    // Create rivalry
    const rivalry = await Relationship.create({
        guildId,
        user1Id: userId,
        user2Id: targetUser.id,
        type: 'rivalry',
        status: 'pending'
    });
    
    const embed = new EmbedBuilder()
        .setColor('#ff6b6b')
        .setTitle('‚öîÔ∏è Th√°ch ƒê·∫•u Rivalry')
        .setDescription(`<@${userId}> th√°ch ƒë·∫•u <@${targetUser.id}> l√†m ƒë·ªëi th·ªß!`)
        .addFields(
            { name: 'üî• L·ª£i √≠ch', value: '+20% XP khi th·∫Øng rival activities', inline: true },
            { name: 'üèÜ Thi ƒë·∫•u', value: 'Unlock special rivalry competitions', inline: true }
        )
        .setFooter({ text: `${targetUser.username} c√≥ th·ªÉ ch·∫•p nh·∫≠n th√°ch ƒë·∫•u` })
        .setTimestamp();

    const acceptButton = new ButtonBuilder()
        .setCustomId(`rival_accept_${rivalry._id}`)
        .setLabel('‚öîÔ∏è Th√°ch ƒê·∫•u')
        .setStyle(ButtonStyle.Danger);

    const declineButton = new ButtonBuilder()
        .setCustomId(`rival_decline_${rivalry._id}`)
        .setLabel('üè≥Ô∏è T·ª´ Ch·ªëi')
        .setStyle(ButtonStyle.Secondary);

    const row = new ActionRowBuilder().addComponents(acceptButton, declineButton);
    
    await interaction.reply({ embeds: [embed], components: [row] });
}

async function handleStatus(interaction) {
    const targetUser = interaction.options.getUser('user') || interaction.user;
    const userId = interaction.user.id;
    const guildId = interaction.guildId;
    
    const relationships = await Relationship.find({
        guildId,
        $or: [
            { user1Id: targetUser.id },
            { user2Id: targetUser.id }
        ],
        status: 'accepted'
    });
    
    if (relationships.length === 0) {
        return interaction.reply({
            embeds: [successEmbed('üíù Tr·∫°ng Th√°i M·ªëi Quan H·ªá', `${targetUser.username} ch∆∞a c√≥ m·ªëi quan h·ªá n√†o.`)],
            ephemeral: true
        });
    }
    
    const embed = new EmbedBuilder()
        .setColor('#48dbfb')
        .setTitle(`üíù M·ªëi Quan H·ªá - ${targetUser.username}`)
        .setThumbnail(targetUser.displayAvatarURL())
        .setTimestamp();
    
    const marriage = relationships.find(r => r.type === 'marriage');
    const friends = relationships.filter(r => r.type === 'friendship');
    const mentorships = relationships.filter(r => r.type === 'mentorship');
    const rivalries = relationships.filter(r => r.type === 'rivalry');
    
    if (marriage) {
        const partnerId = marriage.user1Id === targetUser.id ? marriage.user2Id : marriage.user1Id;
        const daysSince = Math.floor((Date.now() - marriage.marriageDate) / (1000 * 60 * 60 * 24));
        embed.addFields({
            name: 'üíï H√¥n Nh√¢n',
            value: `V·ª£/Ch·ªìng: <@${partnerId}>\nüìÖ ${daysSince} ng√†y k·∫øt h√¥n\nüéÅ ${marriage.bonusesEarned} bonus ƒë√£ nh·∫≠n`,
            inline: false
        });
    }
    
    if (friends.length > 0) {
        const friendList = friends.map(f => {
            const friendId = f.user1Id === targetUser.id ? f.user2Id : f.user1Id;
            return `<@${friendId}> (Lv.${f.friendshipLevel})`;
        }).join(', ');
        embed.addFields({
            name: `ü§ù B·∫°n B√® (${friends.length})`,
            value: friendList,
            inline: false
        });
    }
    
    if (mentorships.length > 0) {
        const mentorshipList = mentorships.map(m => {
            const isMentor = m.mentorId === targetUser.id;
            const otherId = isMentor ? m.menteeId : m.mentorId;
            return `${isMentor ? 'üë®‚Äçüè´' : 'üë®‚Äçüéì'} <@${otherId}> (${m.lessonsCompleted} lessons)`;
        }).join('\n');
        embed.addFields({
            name: 'üéì Mentorship',
            value: mentorshipList,
            inline: false
        });
    }
    
    if (rivalries.length > 0) {
        const rivalryList = rivalries.map(r => {
            const rivalId = r.user1Id === targetUser.id ? r.user2Id : r.user1Id;
            const isUser1 = r.user1Id === targetUser.id;
            const wins = isUser1 ? r.rivalryScore.user1Wins : r.rivalryScore.user2Wins;
            const losses = isUser1 ? r.rivalryScore.user2Wins : r.rivalryScore.user1Wins;
            return `‚öîÔ∏è <@${rivalId}> (${wins}W-${losses}L)`;
        }).join('\n');
        embed.addFields({
            name: '‚öîÔ∏è ƒê·ªëi Th·ªß',
            value: rivalryList,
            inline: false
        });
    }
    
    await interaction.reply({ embeds: [embed] });
}

async function handleBreak(interaction) {
    const targetUser = interaction.options.getUser('user');
    const type = interaction.options.getString('type');
    const userId = interaction.user.id;
    const guildId = interaction.guildId;
    
    const relationship = await Relationship.findOne({
        guildId,
        $or: [
            { user1Id: userId, user2Id: targetUser.id },
            { user1Id: targetUser.id, user2Id: userId }
        ],
        type,
        status: 'accepted'
    });
    
    if (!relationship) {
        return interaction.reply({
            embeds: [errorEmbed(`Kh√¥ng t√¨m th·∫•y m·ªëi quan h·ªá ${type} v·ªõi ng∆∞·ªùi n√†y!`)],
            ephemeral: true
        });
    }
    
    relationship.status = 'broken';
    await relationship.save();
    
    const typeNames = {
        marriage: 'h√¥n nh√¢n',
        friendship: 'b·∫°n b√®', 
        mentorship: 'mentor-mentee',
        rivalry: 'ƒë·ªëi th·ªß'
    };
    
    const embed = new EmbedBuilder()
        .setColor('#ff6b6b')
        .setTitle('üíî M·ªëi Quan H·ªá ƒê√£ K·∫øt Th√∫c')
        .setDescription(`M·ªëi quan h·ªá ${typeNames[type]} gi·ªØa <@${userId}> v√† <@${targetUser.id}> ƒë√£ k·∫øt th√∫c.`)
        .setTimestamp();
    
    await interaction.reply({ embeds: [embed] });
}

async function handleList(interaction) {
    const userId = interaction.user.id;
    const guildId = interaction.guildId;
    
    const relationships = await Relationship.find({
        guildId,
        $or: [{ user1Id: userId }, { user2Id: userId }],
        status: 'accepted'
    });
    
    if (relationships.length === 0) {
        return interaction.reply({
            embeds: [successEmbed('üìã Danh S√°ch M·ªëi Quan H·ªá', 'B·∫°n ch∆∞a c√≥ m·ªëi quan h·ªá n√†o.')],
            ephemeral: true
        });
    }
    
    const embed = new EmbedBuilder()
        .setColor('#48dbfb')
        .setTitle('üìã Danh S√°ch M·ªëi Quan H·ªá C·ªßa B·∫°n')
        .setTimestamp();
    
    const groupedRelationships = relationships.reduce((acc, rel) => {
        if (!acc[rel.type]) acc[rel.type] = [];
        acc[rel.type].push(rel);
        return acc;
    }, {});
    
    for (const [type, rels] of Object.entries(groupedRelationships)) {
        const typeEmojis = {
            marriage: 'üíï',
            friendship: 'ü§ù',
            mentorship: 'üéì',
            rivalry: '‚öîÔ∏è'
        };
        
        const relList = rels.map(rel => {
            const otherId = rel.user1Id === userId ? rel.user2Id : rel.user1Id;
            return `<@${otherId}>`;
        }).join(', ');
        
        embed.addFields({
            name: `${typeEmojis[type]} ${type.charAt(0).toUpperCase() + type.slice(1)} (${rels.length})`,
            value: relList,
            inline: false
        });
    }
    
    await interaction.reply({ embeds: [embed], ephemeral: true });
}