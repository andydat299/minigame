import { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } from 'discord.js';
import User from '../models/User.mjs';
import Giftcode from '../models/Giftcode.mjs';
import { formatCurrency, errorEmbed, successEmbed } from './util.mjs';

export const data = new SlashCommandBuilder()
    .setName('giftcode')
    .setDescription('H·ªá th·ªëng giftcode')
    .addSubcommand(subcommand =>
        subcommand
            .setName('redeem')
            .setDescription('S·ª≠ d·ª•ng giftcode')
            .addStringOption(option =>
                option.setName('code')
                    .setDescription('M√£ giftcode')
                    .setRequired(true)))
    .addSubcommand(subcommand =>
        subcommand
            .setName('create')
            .setDescription('T·∫°o giftcode m·ªõi (Admin only)')
            .addStringOption(option =>
                option.setName('code')
                    .setDescription('M√£ giftcode (ƒë·ªÉ tr·ªëng ƒë·ªÉ t·ª± ƒë·ªông t·∫°o)')
                    .setRequired(false))
            .addIntegerOption(option =>
                option.setName('coins')
                    .setDescription('S·ªë xu th∆∞·ªüng')
                    .setRequired(false)
                    .setMinValue(0))
            .addIntegerOption(option =>
                option.setName('bait')
                    .setDescription('S·ªë m·ªìi th∆∞·ªüng')
                    .setRequired(false)
                    .setMinValue(0))
            .addIntegerOption(option =>
                option.setName('free_fishing')
                    .setDescription('S·ªë l·∫ßn c√¢u mi·ªÖn ph√≠')
                    .setRequired(false)
                    .setMinValue(0))
            .addIntegerOption(option =>
                option.setName('max_uses')
                    .setDescription('S·ªë l·∫ßn s·ª≠ d·ª•ng t·ªëi ƒëa (-1 = kh√¥ng gi·ªõi h·∫°n)')
                    .setRequired(false)
                    .setMinValue(-1))
            .addStringOption(option =>
                option.setName('expires')
                    .setDescription('Th·ªùi gian h·∫øt h·∫°n (v√≠ d·ª•: 7d, 24h, 30m)')
                    .setRequired(false))
            .addStringOption(option =>
                option.setName('description')
                    .setDescription('M√¥ t·∫£ giftcode')
                    .setRequired(false)))
    .addSubcommand(subcommand =>
        subcommand
            .setName('list')
            .setDescription('Xem danh s√°ch giftcode (Admin only)'))
    .addSubcommand(subcommand =>
        subcommand
            .setName('delete')
            .setDescription('X√≥a giftcode (Admin only)')
            .addStringOption(option =>
                option.setName('code')
                    .setDescription('M√£ giftcode c·∫ßn x√≥a')
                    .setRequired(true)))
    .addSubcommand(subcommand =>
        subcommand
            .setName('info')
            .setDescription('Xem th√¥ng tin giftcode')
            .addStringOption(option =>
                option.setName('code')
                    .setDescription('M√£ giftcode')
                    .setRequired(true)));

export async function execute(interaction) {
    const subcommand = interaction.options.getSubcommand();
    
    switch (subcommand) {
        case 'redeem':
            await handleRedeem(interaction);
            break;
        case 'create':
            await handleCreate(interaction);
            break;
        case 'list':
            await handleList(interaction);
            break;
        case 'delete':
            await handleDelete(interaction);
            break;
        case 'info':
            await handleInfo(interaction);
            break;
    }
}

async function handleRedeem(interaction) {
    const code = interaction.options.getString('code').toUpperCase();
    const userId = interaction.user.id;
    const guildId = interaction.guildId;
    
    // Find giftcode
    const giftcode = await Giftcode.findOne({ code, guildId, isActive: true });
    if (!giftcode) {
        return interaction.reply({
            embeds: [errorEmbed('‚ùå Giftcode kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n!')],
            ephemeral: true
        });
    }
    
    // Check expiration
    if (giftcode.expiresAt && giftcode.expiresAt < new Date()) {
        giftcode.isActive = false;
        await giftcode.save();
        return interaction.reply({
            embeds: [errorEmbed('‚è∞ Giftcode ƒë√£ h·∫øt h·∫°n!')],
            ephemeral: true
        });
    }
    
    // Check max uses
    if (giftcode.maxUses !== -1 && giftcode.currentUses >= giftcode.maxUses) {
        return interaction.reply({
            embeds: [errorEmbed('üö´ Giftcode ƒë√£ h·∫øt l∆∞·ª£t s·ª≠ d·ª•ng!')],
            ephemeral: true
        });
    }
    
    // Check if user already used
    if (giftcode.oneTimePerUser && giftcode.usedBy.includes(userId)) {
        return interaction.reply({
            embeds: [errorEmbed('üîÑ B·∫°n ƒë√£ s·ª≠ d·ª•ng giftcode n√†y r·ªìi!')],
            ephemeral: true
        });
    }
    
    // Get or create user profile
    let profile = await User.findOne({ userId, guildId });
    if (!profile) {
        profile = await User.create({ userId, guildId });
    }
    
    // Apply rewards
    const rewards = [];
    
    if (giftcode.rewards.coins > 0) {
        profile.coins = (profile.coins || 0) + giftcode.rewards.coins;
        rewards.push(`üí∞ ${formatCurrency(giftcode.rewards.coins)}`);
    }
    
    if (giftcode.rewards.bait > 0) {
        profile.bait = (profile.bait || 0) + giftcode.rewards.bait;
        rewards.push(`ü™± ${giftcode.rewards.bait} m·ªìi`);
    }
    
    if (giftcode.rewards.freeFishingTries > 0) {
        profile.freeFishingTries = (profile.freeFishingTries || 0) + giftcode.rewards.freeFishingTries;
        rewards.push(`üéÅ ${giftcode.rewards.freeFishingTries} l·∫ßn c√¢u mi·ªÖn ph√≠`);
    }
    
    // Handle items
    if (giftcode.rewards.items && giftcode.rewards.items.size > 0) {
        for (const [itemName, quantity] of giftcode.rewards.items) {
            const currentQty = profile.items?.get(itemName) || 0;
            profile.items.set(itemName, currentQty + quantity);
            rewards.push(`üì¶ ${quantity}x ${itemName}`);
        }
    }
    
    await profile.save();
    
    // Update giftcode usage
    giftcode.currentUses += 1;
    giftcode.usedBy.push(userId);
    await giftcode.save();
    
    const embed = new EmbedBuilder()
        .setColor('#00ff00')
        .setTitle('üéâ Giftcode ƒê√£ ƒê∆∞·ª£c S·ª≠ d·ª•ng!')
        .setDescription(`**M√£: \`${code}\`**\n${giftcode.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}`)
        .addFields(
            { name: 'üéÅ Ph·∫ßn th∆∞·ªüng nh·∫≠n ƒë∆∞·ª£c', value: rewards.join('\n') || 'Kh√¥ng c√≥', inline: false },
            { name: 'üí∞ T·ªïng xu hi·ªán t·∫°i', value: formatCurrency(profile.coins), inline: true },
            { name: 'ü™± T·ªïng m·ªìi hi·ªán t·∫°i', value: `${profile.bait || 0}`, inline: true },
            { name: 'üéÅ L·∫ßn c√¢u mi·ªÖn ph√≠', value: `${profile.freeFishingTries || 0}`, inline: true }
        )
        .setFooter({ text: 'Ch√∫c m·ª´ng b·∫°n!' })
        .setTimestamp();
    
    await interaction.reply({ embeds: [embed] });
}

async function handleCreate(interaction) {
    // Check admin permissions
    if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
        return interaction.reply({
            embeds: [errorEmbed('‚ùå B·∫°n c·∫ßn quy·ªÅn Administrator ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!')],
            ephemeral: true
        });
    }
    
    const guildId = interaction.guildId;
    const createdBy = interaction.user.id;
    
    // Get options
    let code = interaction.options.getString('code');
    const coins = interaction.options.getInteger('coins') || 0;
    const bait = interaction.options.getInteger('bait') || 0;
    const freeFishing = interaction.options.getInteger('free_fishing') || 0;
    const maxUses = interaction.options.getInteger('max_uses') || 1;
    const expiresInput = interaction.options.getString('expires');
    const description = interaction.options.getString('description') || '';
    
    // Generate random code if not provided
    if (!code) {
        code = generateRandomCode();
    } else {
        code = code.toUpperCase();
    }
    
    // Check if code already exists
    const existingCode = await Giftcode.findOne({ code, guildId });
    if (existingCode) {
        return interaction.reply({
            embeds: [errorEmbed('‚ùå Giftcode n√†y ƒë√£ t·ªìn t·∫°i!')],
            ephemeral: true
        });
    }
    
    // Parse expiration
    let expiresAt = null;
    if (expiresInput) {
        expiresAt = parseExpiration(expiresInput);
        if (!expiresAt) {
            return interaction.reply({
                embeds: [errorEmbed('‚ùå ƒê·ªãnh d·∫°ng th·ªùi gian kh√¥ng h·ª£p l·ªá! (V√≠ d·ª•: 7d, 24h, 30m)')],
                ephemeral: true
            });
        }
    }
    
    // Create giftcode
    const giftcode = await Giftcode.create({
        code,
        guildId,
        createdBy,
        rewards: {
            coins,
            bait,
            freeFishingTries: freeFishing
        },
        maxUses,
        expiresAt,
        description
    });
    
    const rewardsList = [];
    if (coins > 0) rewardsList.push(`üí∞ ${formatCurrency(coins)}`);
    if (bait > 0) rewardsList.push(`ü™± ${bait} m·ªìi`);
    if (freeFishing > 0) rewardsList.push(`üéÅ ${freeFishing} l·∫ßn c√¢u mi·ªÖn ph√≠`);
    
    const embed = new EmbedBuilder()
        .setColor('#00ff00')
        .setTitle('‚úÖ Giftcode ƒê√£ ƒê∆∞·ª£c T·∫°o!')
        .addFields(
            { name: 'üè∑Ô∏è M√£', value: `\`${code}\``, inline: true },
            { name: 'üéÅ Ph·∫ßn th∆∞·ªüng', value: rewardsList.join('\n') || 'Kh√¥ng c√≥', inline: true },
            { name: 'üî¢ L∆∞·ª£t s·ª≠ d·ª•ng', value: maxUses === -1 ? 'Kh√¥ng gi·ªõi h·∫°n' : `${maxUses}`, inline: true },
            { name: '‚è∞ H·∫øt h·∫°n', value: expiresAt ? `<t:${Math.floor(expiresAt.getTime() / 1000)}:R>` : 'Kh√¥ng bao gi·ªù', inline: true },
            { name: 'üìù M√¥ t·∫£', value: description || 'Kh√¥ng c√≥', inline: false }
        )
        .setFooter({ text: 'Chia s·∫ª m√£ n√†y cho th√†nh vi√™n!' })
        .setTimestamp();
    
    await interaction.reply({ embeds: [embed] });
}

async function handleList(interaction) {
    // Check admin permissions
    if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
        return interaction.reply({
            embeds: [errorEmbed('‚ùå B·∫°n c·∫ßn quy·ªÅn Administrator ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!')],
            ephemeral: true
        });
    }
    
    const guildId = interaction.guildId;
    const giftcodes = await Giftcode.find({ guildId }).sort({ createdAt: -1 }).limit(10);
    
    if (giftcodes.length === 0) {
        return interaction.reply({
            embeds: [errorEmbed('üì≠ Ch∆∞a c√≥ giftcode n√†o!')],
            ephemeral: true
        });
    }
    
    const embed = new EmbedBuilder()
        .setColor('#0099ff')
        .setTitle('üìã Danh S√°ch Giftcode')
        .setDescription('10 giftcode g·∫ßn nh·∫•t:')
        .setTimestamp();
    
    for (const giftcode of giftcodes) {
        const status = giftcode.isActive ? 
            (giftcode.expiresAt && giftcode.expiresAt < new Date() ? '‚è∞ H·∫øt h·∫°n' : '‚úÖ Ho·∫°t ƒë·ªông') : 
            '‚ùå V√¥ hi·ªáu';
        
        const usage = giftcode.maxUses === -1 ? 
            `${giftcode.currentUses}/‚àû` : 
            `${giftcode.currentUses}/${giftcode.maxUses}`;
        
        const rewards = [];
        if (giftcode.rewards.coins > 0) rewards.push(`${formatCurrency(giftcode.rewards.coins)}`);
        if (giftcode.rewards.bait > 0) rewards.push(`${giftcode.rewards.bait} m·ªìi`);
        if (giftcode.rewards.freeFishingTries > 0) rewards.push(`${giftcode.rewards.freeFishingTries} free`);
        
        embed.addFields({
            name: `\`${giftcode.code}\` ${status}`,
            value: `üéÅ ${rewards.join(', ') || 'Kh√¥ng c√≥'}\nüìä S·ª≠ d·ª•ng: ${usage}\nüìù ${giftcode.description || 'Kh√¥ng c√≥ m√¥ t·∫£'}`,
            inline: true
        });
    }
    
    await interaction.reply({ embeds: [embed], ephemeral: true });
}

async function handleDelete(interaction) {
    // Check admin permissions
    if (!interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
        return interaction.reply({
            embeds: [errorEmbed('‚ùå B·∫°n c·∫ßn quy·ªÅn Administrator ƒë·ªÉ s·ª≠ d·ª•ng l·ªánh n√†y!')],
            ephemeral: true
        });
    }
    
    const code = interaction.options.getString('code').toUpperCase();
    const guildId = interaction.guildId;
    
    const giftcode = await Giftcode.findOneAndDelete({ code, guildId });
    if (!giftcode) {
        return interaction.reply({
            embeds: [errorEmbed('‚ùå Kh√¥ng t√¨m th·∫•y giftcode!')],
            ephemeral: true
        });
    }
    
    await interaction.reply({
        embeds: [successEmbed(`‚úÖ ƒê√£ x√≥a giftcode \`${code}\`!`)],
        ephemeral: true
    });
}

async function handleInfo(interaction) {
    const code = interaction.options.getString('code').toUpperCase();
    const guildId = interaction.guildId;
    
    const giftcode = await Giftcode.findOne({ code, guildId });
    if (!giftcode) {
        return interaction.reply({
            embeds: [errorEmbed('‚ùå Giftcode kh√¥ng t·ªìn t·∫°i!')],
            ephemeral: true
        });
    }
    
    const status = giftcode.isActive ? 
        (giftcode.expiresAt && giftcode.expiresAt < new Date() ? '‚è∞ H·∫øt h·∫°n' : '‚úÖ Ho·∫°t ƒë·ªông') : 
        '‚ùå V√¥ hi·ªáu';
    
    const usage = giftcode.maxUses === -1 ? 
        `${giftcode.currentUses}/‚àû` : 
        `${giftcode.currentUses}/${giftcode.maxUses}`;
    
    const rewards = [];
    if (giftcode.rewards.coins > 0) rewards.push(`üí∞ ${formatCurrency(giftcode.rewards.coins)}`);
    if (giftcode.rewards.bait > 0) rewards.push(`ü™± ${giftcode.rewards.bait} m·ªìi`);
    if (giftcode.rewards.freeFishingTries > 0) rewards.push(`üéÅ ${giftcode.rewards.freeFishingTries} l·∫ßn c√¢u mi·ªÖn ph√≠`);
    
    const embed = new EmbedBuilder()
        .setColor(giftcode.isActive ? '#00ff00' : '#ff6b6b')
        .setTitle(`üè∑Ô∏è Th√¥ng Tin Giftcode: \`${code}\``)
        .addFields(
            { name: 'üìä Tr·∫°ng th√°i', value: status, inline: true },
            { name: 'üî¢ S·ª≠ d·ª•ng', value: usage, inline: true },
            { name: '‚è∞ H·∫øt h·∫°n', value: giftcode.expiresAt ? `<t:${Math.floor(giftcode.expiresAt.getTime() / 1000)}:R>` : 'Kh√¥ng bao gi·ªù', inline: true },
            { name: 'üéÅ Ph·∫ßn th∆∞·ªüng', value: rewards.join('\n') || 'Kh√¥ng c√≥', inline: false },
            { name: 'üìù M√¥ t·∫£', value: giftcode.description || 'Kh√¥ng c√≥', inline: false }
        )
        .setFooter({ text: `T·∫°o b·ªüi: ${giftcode.createdBy}` })
        .setTimestamp(giftcode.createdAt);
    
    await interaction.reply({ embeds: [embed] });
}

// Helper functions
function generateRandomCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let result = '';
    for (let i = 0; i < 8; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

function parseExpiration(input) {
    const match = input.match(/^(\d+)([dhm])$/);
    if (!match) return null;
    
    const amount = parseInt(match[1]);
    const unit = match[2];
    
    const now = new Date();
    switch (unit) {
        case 'd':
            return new Date(now.getTime() + amount * 24 * 60 * 60 * 1000);
        case 'h':
            return new Date(now.getTime() + amount * 60 * 60 * 1000);
        case 'm':
            return new Date(now.getTime() + amount * 60 * 1000);
        default:
            return null;
    }
}