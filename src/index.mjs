import { Client, GatewayIntentBits, Collection, Events, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle } from 'discord.js';
import mongoose from 'mongoose';
import chalk from 'chalk';
import { MONGO_URI, TOKEN } from './config.mjs';
import User from './models/User.mjs';
import Loan from './models/Loan.mjs';
import Relationship from './models/Relationship.mjs';
import ProfileTheme from './models/ProfileTheme.mjs';
import { formatCurrency } from './commands/util.mjs';
import { initializeGiftcodeCleanup } from './utils/giftcodeManager.mjs';
import * as fish from './commands/fish.mjs';
import * as inventory from './commands/inventory.mjs';
import * as sellall from './commands/sellall.mjs';
import * as profile from './commands/profile.mjs';
import * as upgrade from './commands/upgrade.mjs';
import * as leaderboard from './commands/leaderboard.mjs';
import * as addcash from './commands/addcash.mjs';
import * as shop from './commands/shop.mjs';
import * as give from './commands/give.mjs';
import * as stats from './commands/stats.mjs';
import * as use from './commands/use.mjs';
import * as effects from './commands/effects.mjs';
import * as boss from './commands/boss.mjs';
import * as fishingevent from './commands/fishingevent.mjs';
import * as ban from './commands/ban-new.mjs';
import * as repair from './commands/repair.mjs';
import * as daily from './commands/daily.mjs';
import * as casino from './commands/casino.mjs';
import * as achievements from './commands/achievements.mjs';
import * as auction from './commands/quest.mjs';
import * as quest from './commands/quest.mjs';
import * as loan from './commands/loan.mjs';
import * as credit from './commands/credit.mjs';
import * as relationship from './commands/relationship.mjs';
import * as blackjack from './commands/blackjack.mjs';
import * as theme from './commands/theme.mjs';
import * as taixiu from './commands/taixiu.mjs';
import GuildConfig from './models/GuildConfig.mjs';
import { initEventScheduler } from './commands/fishingevent.mjs';
import { initializeQuests } from './game/questManager.mjs';
import { initLoanChecker } from './game/loanManager.mjs';
import { checkBanStatus } from './middleware/banCheck.mjs';

const client = new Client({ intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMembers] });
const modules = [
  fish, inventory, sellall, profile, upgrade, leaderboard, addcash, shop, give, stats, use, effects, boss, 
  fishingevent, ban, repair, daily, casino, achievements, auction, quest, loan, credit,
  relationship, blackjack, theme, taixiu
];
const commandMap = new Collection(); 
for (const m of modules) commandMap.set(m.data.name, m);

client.once(Events.ClientReady, async (c)=>{
  console.log(chalk.green(`[ready] Logged in as ${c.user.tag}`));
  try { await mongoose.connect(MONGO_URI); console.log(chalk.cyan(`[db] Connected to MongoDB`)); } catch (err) { console.error(chalk.red(`[db] error`), err); process.exit(1); }
  // Boss scheduler: check every 30s VN hour windows
  setInterval(async ()=>{
    try {
      const guilds = await GuildConfig.find({});
      const now = new Date();
      const vn = new Date(Date.now() + 7*60*60*1000);
      const curHour = vn.getUTCHours();
      for (const g of guilds){
        if (!g.bossHours || g.bossHours.length===0) continue;
        const active = g.bossActiveUntil && g.bossActiveUntil > now;
        const inHour = g.bossHours.includes(curHour);
        if (inHour && !active){ g.bossActiveUntil = new Date(now.getTime() + (g.bossDurationMin||15)*60*1000); await g.save(); }
        if (!inHour && active && g.bossActiveUntil < now){ g.bossActiveUntil = null; await g.save(); }
      }
    } catch (e) { console.error('[scheduler]', e); }
  }, 30_000);
  // Initialize quest system and event scheduler
await initializeQuests();
initEventScheduler();
  // Initialize giftcode system
  initializeGiftcodeCleanup();
});

client.on(Events.InteractionCreate, async (interaction)=>{
  if (interaction.isChatInputCommand()) {
    // Check if user is banned (except for ban command itself)
    if (interaction.commandName !== 'ban') {
        const isBanned = await checkBanStatus(interaction);
        if (isBanned) return; // Stop execution if user is banned
    }

    const cmd = commandMap.get(interaction.commandName);
    if (!cmd) { await interaction.reply({ ephemeral:true, content:"L·ªánh kh√¥ng t·ªìn t·∫°i." }); return; }
    try { await cmd.execute(interaction); } catch (err) {
      console.error(err);
      if (interaction.deferred||interaction.replied) await interaction.followUp({ ephemeral:true, content:"ƒê√£ c√≥ l·ªói x·∫£y ra." });
      else await interaction.reply({ ephemeral:true, content:"ƒê√£ c√≥ l·ªói x·∫£y ra." });
    }
  } else if (interaction.isButton()) {
    // Handle button interactions
    await handleButtonInteraction(interaction);
  } else if (interaction.isModalSubmit()) {
    // Handle modal submissions
    await handleModalSubmit(interaction);
  } else if (interaction.isModalSubmit()) {
    if (interaction.customId === 'giftcode_modal') {
      await handleGiftcodeModal(interaction);
    } else if (interaction.customId === 'tx_custom_amount_modal') {
      await handleCustomAmountModal(interaction);
    }
  }
});

client.login(TOKEN);

// Handle button interactions
async function handleButtonInteraction(interaction) {
  try {
    const customId = interaction.customId;
    
    if (customId.startsWith('loan_accept_')) {
      await handleLoanAccept(interaction);
    } else if (customId.startsWith('loan_decline_')) {
      await handleLoanDecline(interaction);
    } else if (customId.startsWith('loan_approve_')) {
      await handleLoanApprove(interaction);
    } else if (customId.startsWith('marry_accept_')) {
      await handleMarryAccept(interaction);
    } else if (customId.startsWith('marry_decline_')) {
      await handleMarryDecline(interaction);
    } else if (customId.startsWith('friend_accept_')) {
      await handleFriendAccept(interaction);
    } else if (customId.startsWith('friend_decline_')) {
      await handleFriendDecline(interaction);
    } else if (customId.startsWith('mentor_accept_')) {
      await handleMentorAccept(interaction);
    } else if (customId.startsWith('mentor_decline_')) {
      await handleMentorDecline(interaction);
    } else if (customId.startsWith('rival_accept_')) {
      await handleRivalAccept(interaction);
    } else if (customId.startsWith('rival_decline_')) {
      await handleRivalDecline(interaction);
    } else if (customId.startsWith('bj_')) {
      await handleBlackjackAction(interaction);
    } else if (customId.startsWith('theme_')) {
      await handleThemeAction(interaction);
    } else if (customId.startsWith('mood_')) {
      await handleMoodSelection(interaction);
    } else if (customId.startsWith('tx_')) {
      await handleTaiXiuAction(interaction);
    } else if (customId.startsWith('quickbet_')) {
      await handleQuickBet(interaction);
    } else if (customId === 'tx_play_custom') {
      await handleTaiXiuCustomPlay(interaction);
    } else if (customId === 'taixiu_analysis') {
      await handleTaiXiuAnalysis(interaction);
    } else if (customId === 'taixiu_custom') {
      await handleTaiXiuCustomPlay(interaction);
    } else if (customId === 'quick_giftcode') {
      await handleQuickGiftcode(interaction);
    }
  } catch (error) {
    console.error('Button interaction error:', error);
    if (!interaction.replied && !interaction.deferred) {
      await interaction.reply({ content: 'C√≥ l·ªói x·∫£y ra!', ephemeral: true });
    }
  }
}

// Loan button handlers
async function handleLoanAccept(interaction) {
  const loanId = interaction.customId.replace('loan_accept_', '');
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  const loan = await Loan.findOne({ loanId, guildId, status: 'pending' });
  if (!loan) {
    return interaction.reply({ content: 'Kho·∫£n vay kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω!', ephemeral: true });
  }
  
  if (loan.borrowerId !== userId) {
    return interaction.reply({ content: 'Ch·ªâ ng∆∞·ªùi vay m·ªõi c√≥ th·ªÉ ch·∫•p nh·∫≠n!', ephemeral: true });
  }
  
  // Process loan acceptance
  let lenderProfile = await User.findOne({ userId: loan.lenderId, guildId });
  if (!lenderProfile || (lenderProfile.coins || 0) < loan.amount) {
    return interaction.reply({ content: 'Ng∆∞·ªùi cho vay kh√¥ng ƒë·ªß ti·ªÅn!', ephemeral: true });
  }
  
  let borrowerProfile = await User.findOne({ userId: loan.borrowerId, guildId });
  if (!borrowerProfile) borrowerProfile = await User.create({ userId: loan.borrowerId, guildId });
  
  // Transfer money
  lenderProfile.coins = (lenderProfile.coins || 0) - loan.amount;
  borrowerProfile.coins = (borrowerProfile.coins || 0) + loan.amount;
  
  loan.status = 'active';
  loan.approvedAt = new Date();
  
  await lenderProfile.save();
  await borrowerProfile.save();
  await loan.save();
  
  // Create new embed for success message
  const successEmbed = new EmbedBuilder()
    .setColor('#00ff00')
    .setTitle('‚úÖ Kho·∫£n Vay ƒê√£ ƒê∆∞·ª£c Ch·∫•p Nh·∫≠n')
    .setDescription(`<@${loan.lenderId}> v√† <@${loan.borrowerId}> ƒë√£ ho√†n th√†nh giao d·ªãch!`)
    .addFields(
      { name: 'üíµ S·ªë Ti·ªÅn Vay', value: `${loan.amount.toLocaleString()} xu`, inline: true },
      { name: 'üí∞ T·ªïng Ph·∫£i Tr·∫£', value: `${loan.totalRepayment.toLocaleString()} xu`, inline: true },
      { name: 'üìÖ H·∫°n Tr·∫£', value: `<t:${Math.floor(loan.dueDate.getTime() / 1000)}:F>`, inline: true }
    )
    .setFooter({ text: 'Kho·∫£n vay ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t!' })
    .setTimestamp();
  
  await interaction.update({ embeds: [successEmbed], components: [] });
}

async function handleLoanDecline(interaction) {
  const loanId = interaction.customId.replace('loan_decline_', '');
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  const loan = await Loan.findOne({ loanId, guildId, status: 'pending' });
  if (!loan) {
    return interaction.reply({ content: 'Kho·∫£n vay kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω!', ephemeral: true });
  }
  
  if (loan.borrowerId !== userId && loan.lenderId !== userId) {
    return interaction.reply({ content: 'B·∫°n kh√¥ng c√≥ quy·ªÅn t·ª´ ch·ªëi kho·∫£n vay n√†y!', ephemeral: true });
  }
  
  loan.status = 'cancelled';
  await loan.save();
  
  // Create new embed for decline message
  const declineEmbed = new EmbedBuilder()
    .setColor('#ff6b6b')
    .setTitle('‚ùå Kho·∫£n Vay ƒê√£ B·ªã T·ª´ Ch·ªëi')
    .setDescription('Kho·∫£n vay ƒë√£ b·ªã h·ªßy b·ªüi m·ªôt trong hai b√™n.')
    .setFooter({ text: 'Giao d·ªãch ƒë√£ k·∫øt th√∫c!' })
    .setTimestamp();
  
  await interaction.update({ embeds: [declineEmbed], components: [] });
}

async function handleLoanApprove(interaction) {
  const parts = interaction.customId.split('_');
  const loanId = parts[2];
  const interestRate = parseFloat(parts[3]);
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  const loan = await Loan.findOne({ loanId, guildId, status: 'pending' });
  if (!loan) {
    return interaction.reply({ content: 'Kho·∫£n vay kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω!', ephemeral: true });
  }
  
  if (loan.lenderId !== userId) {
    return interaction.reply({ content: 'Ch·ªâ ng∆∞·ªùi cho vay m·ªõi c√≥ th·ªÉ ph√™ duy·ªát!', ephemeral: true });
  }
  
  // Update loan with interest rate
  const dailyInterest = (loan.amount * interestRate / 100);
  const totalInterest = dailyInterest * loan.duration;
  const totalRepayment = Math.ceil(loan.amount + totalInterest);
  
  loan.interestRate = interestRate;
  loan.totalRepayment = totalRepayment;
  loan.remainingAmount = totalRepayment;
  await loan.save();
  
  // Create new embed with updated terms
  const updatedEmbed = new EmbedBuilder()
    .setColor('#48dbfb')
    .setTitle('üí∞ ƒê·ªÅ Ngh·ªã Cho Vay ƒê√£ ƒê∆∞·ª£c C·∫≠p Nh·∫≠t')
    .setDescription(`<@${loan.lenderId}> ƒë√£ ph√™ duy·ªát v·ªõi l√£i su·∫•t ${interestRate}%/ng√†y!`)
    .addFields(
      { name: 'üíµ S·ªë Ti·ªÅn Vay', value: `${loan.amount.toLocaleString()} xu`, inline: true },
      { name: 'üìà L√£i Su·∫•t', value: `${interestRate}%/ng√†y`, inline: true },
      { name: '‚è∞ Th·ªùi H·∫°n', value: `${loan.duration} ng√†y`, inline: true },
      { name: 'üí∞ T·ªïng Ph·∫£i Tr·∫£', value: `${totalRepayment.toLocaleString()} xu`, inline: true },
      { name: 'üìÖ H·∫°n Tr·∫£', value: `<t:${Math.floor(loan.dueDate.getTime() / 1000)}:F>`, inline: true }
    )
    .setFooter({ text: 'Ng∆∞·ªùi vay c√≥ th·ªÉ ch·∫•p nh·∫≠n ho·∫∑c t·ª´ ch·ªëi ƒë·ªÅ ngh·ªã n√†y' })
    .setTimestamp();
  
  const acceptButton = new ButtonBuilder()
    .setCustomId(`loan_accept_${loanId}`)
    .setLabel('‚úÖ Ch·∫•p Nh·∫≠n')
    .setStyle(ButtonStyle.Success);
  
  const declineButton = new ButtonBuilder()
    .setCustomId(`loan_decline_${loanId}`)
    .setLabel('‚ùå T·ª´ Ch·ªëi')
    .setStyle(ButtonStyle.Danger);
  
  const row = new ActionRowBuilder().addComponents(acceptButton, declineButton);
  
  await interaction.update({ embeds: [updatedEmbed], components: [row] });
}

// Relationship button handlers
async function handleMarryAccept(interaction) {
  const relationshipId = interaction.customId.replace('marry_accept_', '');
  const userId = interaction.user.id;
  
  const relationship = await Relationship.findById(relationshipId);
  if (!relationship || relationship.status !== 'pending') {
    return interaction.reply({ content: 'L·ªùi c·∫ßu h√¥n kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω!', ephemeral: true });
  }
  
  if (relationship.user2Id !== userId) {
    return interaction.reply({ content: 'B·∫°n kh√¥ng ph·∫£i ng∆∞·ªùi ƒë∆∞·ª£c c·∫ßu h√¥n!', ephemeral: true });
  }
  
  relationship.status = 'accepted';
  relationship.marriageDate = new Date();
  await relationship.save();
  
  const successEmbed = new EmbedBuilder()
    .setColor('#ff69b4')
    .setTitle('üíï K·∫øt H√¥n Th√†nh C√¥ng!')
    .setDescription(`<@${relationship.user1Id}> v√† <@${relationship.user2Id}> ƒë√£ k·∫øt h√¥n! üéâ`)
    .addFields(
      { name: 'üíç Ng√†y c∆∞·ªõi', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
      { name: 'üéÅ Bonus', value: '+10% xu khi c√πng ho·∫°t ƒë·ªông', inline: true }
    )
    .setTimestamp();
  
  await interaction.update({ embeds: [successEmbed], components: [] });
}

async function handleMarryDecline(interaction) {
  const relationshipId = interaction.customId.replace('marry_decline_', '');
  const relationship = await Relationship.findById(relationshipId);
  
  if (relationship) {
    relationship.status = 'rejected';
    await relationship.save();
  }
  
  const declineEmbed = new EmbedBuilder()
    .setColor('#ff6b6b')
    .setTitle('üíî L·ªùi C·∫ßu H√¥n B·ªã T·ª´ Ch·ªëi')
    .setDescription('L·ªùi c·∫ßu h√¥n ƒë√£ b·ªã t·ª´ ch·ªëi.')
    .setTimestamp();
  
  await interaction.update({ embeds: [declineEmbed], components: [] });
}

async function handleFriendAccept(interaction) {
  const relationshipId = interaction.customId.replace('friend_accept_', '');
  const relationship = await Relationship.findById(relationshipId);
  
  if (relationship) {
    relationship.status = 'accepted';
    await relationship.save();
  }
  
  const successEmbed = new EmbedBuilder()
    .setColor('#48dbfb')
    .setTitle('ü§ù K·∫øt B·∫°n Th√†nh C√¥ng!')
    .setDescription(`<@${relationship.user1Id}> v√† <@${relationship.user2Id}> ƒë√£ tr·ªü th√†nh b·∫°n b√®!`)
    .setTimestamp();
  
  await interaction.update({ embeds: [successEmbed], components: [] });
}

async function handleFriendDecline(interaction) {
  const relationshipId = interaction.customId.replace('friend_decline_', '');
  const relationship = await Relationship.findById(relationshipId);
  
  if (relationship) {
    relationship.status = 'rejected';
    await relationship.save();
  }
  
  const declineEmbed = new EmbedBuilder()
    .setColor('#ff6b6b')
    .setTitle('‚ùå T·ª´ Ch·ªëi K·∫øt B·∫°n')
    .setDescription('L·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ b·ªã t·ª´ ch·ªëi.')
    .setTimestamp();
  
  await interaction.update({ embeds: [declineEmbed], components: [] });
}

async function handleMentorAccept(interaction) {
  const relationshipId = interaction.customId.replace('mentor_accept_', '');
  const relationship = await Relationship.findById(relationshipId);
  
  if (relationship) {
    relationship.status = 'accepted';
    await relationship.save();
  }
  
  const successEmbed = new EmbedBuilder()
    .setColor('#feca57')
    .setTitle('üéì Mentorship Th√†nh C√¥ng!')
    .setDescription(`M·ªëi quan h·ªá mentor-mentee ƒë√£ ƒë∆∞·ª£c thi·∫øt l·∫≠p!`)
    .setTimestamp();
  
  await interaction.update({ embeds: [successEmbed], components: [] });
}

async function handleMentorDecline(interaction) {
  const relationshipId = interaction.customId.replace('mentor_decline_', '');
  const relationship = await Relationship.findById(relationshipId);
  
  if (relationship) {
    relationship.status = 'rejected';
    await relationship.save();
  }
  
  const declineEmbed = new EmbedBuilder()
    .setColor('#ff6b6b')
    .setTitle('‚ùå T·ª´ Ch·ªëi Mentorship')
    .setDescription('ƒê·ªÅ ngh·ªã mentorship ƒë√£ b·ªã t·ª´ ch·ªëi.')
    .setTimestamp();
  
  await interaction.update({ embeds: [declineEmbed], components: [] });
}

async function handleRivalAccept(interaction) {
  const relationshipId = interaction.customId.replace('rival_accept_', '');
  const relationship = await Relationship.findById(relationshipId);
  
  if (relationship) {
    relationship.status = 'accepted';
    await relationship.save();
  }
  
  const successEmbed = new EmbedBuilder()
    .setColor('#ff6b6b')
    .setTitle('‚öîÔ∏è Rivalry Th√†nh L·∫≠p!')
    .setDescription(`Cu·ªôc ƒë·ªëi ƒë·∫ßu ƒë√£ b·∫Øt ƒë·∫ßu! Ai s·∫Ω l√† ng∆∞·ªùi chi·∫øn th·∫Øng?`)
    .setTimestamp();
  
  await interaction.update({ embeds: [successEmbed], components: [] });
}

async function handleRivalDecline(interaction) {
  const relationshipId = interaction.customId.replace('rival_decline_', '');
  const relationship = await Relationship.findById(relationshipId);
  
  if (relationship) {
    relationship.status = 'rejected';
    await relationship.save();
  }
  
  const declineEmbed = new EmbedBuilder()
    .setColor('#ff6b6b')
    .setTitle('üè≥Ô∏è T·ª´ Ch·ªëi Th√°ch ƒê·∫•u')
    .setDescription('Th√°ch ƒë·∫•u rivalry ƒë√£ b·ªã t·ª´ ch·ªëi.')
    .setTimestamp();
  
  await interaction.update({ embeds: [declineEmbed], components: [] });
}

// Blackjack button handler
async function handleBlackjackAction(interaction) {
  const userId = interaction.user.id;
  const action = interaction.customId.split('_')[1]; // hit, stand, double
  
  const gameState = global.blackjackGames?.get(userId);
  if (!gameState) {
    return interaction.reply({ content: 'Game session ƒë√£ h·∫øt h·∫°n!', ephemeral: true });
  }
  
  const { calculateScore, formatCards, drawCard } = await import('./commands/blackjack.mjs');
  
  if (action === 'hit') {
    // Player hits
    const newCard = drawCard(gameState.deck);
    gameState.playerCards.push(newCard);
    const playerScore = calculateScore(gameState.playerCards);
    
    if (playerScore > 21) {
      // Bust
      const profile = await User.findOne({ userId: gameState.userId, guildId: gameState.guildId });
      profile.coins = (profile.coins || 0) - gameState.bet;
      await profile.save();
      
      const bustEmbed = new EmbedBuilder()
        .setColor('#ff6b6b')
        .setTitle('üÉè Blackjack - Bust!')
        .addFields(
          { name: 'üé¥ B√†i c·ªßa b·∫°n', value: formatCards(gameState.playerCards) + ` = **${playerScore}** üí•`, inline: true },
          { name: 'üí∞ K·∫øt qu·∫£', value: `Bust! M·∫•t ${formatCurrency(gameState.bet)}`, inline: false }
        )
        .setTimestamp();
      
      global.blackjackGames.delete(userId);
      await interaction.update({ embeds: [bustEmbed], components: [] });
    } else {
      // Continue game
      const dealerVisibleScore = calculateScore([gameState.dealerCards[0]]);
      
      const embed = new EmbedBuilder()
        .setColor('#48dbfb')
        .setTitle('üÉè Blackjack')
        .addFields(
          { name: 'üé¥ B√†i c·ªßa b·∫°n', value: formatCards(gameState.playerCards) + ` = **${playerScore}**`, inline: true },
          { name: 'üé≠ B√†i dealer', value: formatCards([gameState.dealerCards[0], '‚ùì']) + ` = **${dealerVisibleScore}+**`, inline: true }
        )
        .setTimestamp();
      
      const hitButton = new ButtonBuilder()
        .setCustomId(`bj_hit_${Date.now()}`)
        .setLabel('üéØ Hit')
        .setStyle(ButtonStyle.Primary);
      
      const standButton = new ButtonBuilder()
        .setCustomId(`bj_stand_${Date.now()}`)
        .setLabel('üõë Stand')
        .setStyle(ButtonStyle.Secondary);
      
      const row = new ActionRowBuilder().addComponents(hitButton, standButton);
      
      await interaction.update({ embeds: [embed], components: [row] });
    }
  } else if (action === 'stand') {
    // Dealer plays
    let dealerScore = calculateScore(gameState.dealerCards);
    while (dealerScore < 17) {
      gameState.dealerCards.push(drawCard(gameState.deck));
      dealerScore = calculateScore(gameState.dealerCards);
    }
    
    const playerScore = calculateScore(gameState.playerCards);
    const profile = await User.findOne({ userId: gameState.userId, guildId: gameState.guildId });
    
    let result = '';
    let color = '';
    
    if (dealerScore > 21) {
      // Dealer bust, player wins
      const winAmount = gameState.bet;
      profile.coins = (profile.coins || 0) + winAmount;
      result = `Dealer bust! Th·∫Øng ${formatCurrency(winAmount)}!`;
      color = '#00ff00';
    } else if (playerScore > dealerScore) {
      // Player wins
      const winAmount = gameState.bet;
      profile.coins = (profile.coins || 0) + winAmount;
      result = `Th·∫Øng! +${formatCurrency(winAmount)}`;
      color = '#00ff00';
    } else if (playerScore < dealerScore) {
      // Player loses
      profile.coins = (profile.coins || 0) - gameState.bet;
      result = `Thua! -${formatCurrency(gameState.bet)}`;
      color = '#ff6b6b';
    } else {
      // Tie
      result = 'H√≤a! Ti·ªÅn c∆∞·ª£c ƒë∆∞·ª£c ho√†n l·∫°i.';
      color = '#feca57';
    }
    
    await profile.save();
    
    const finalEmbed = new EmbedBuilder()
      .setColor(color)
      .setTitle('üÉè Blackjack - K·∫øt Qu·∫£')
      .addFields(
        { name: 'üé¥ B√†i c·ªßa b·∫°n', value: formatCards(gameState.playerCards) + ` = **${playerScore}**`, inline: true },
        { name: 'üé≠ B√†i dealer', value: formatCards(gameState.dealerCards) + ` = **${dealerScore}**`, inline: true },
        { name: 'üí∞ K·∫øt qu·∫£', value: result, inline: false }
      )
      .setTimestamp();
    
    global.blackjackGames.delete(userId);
    await interaction.update({ embeds: [finalEmbed], components: [] });
  }
}

// Theme button handler
async function handleThemeAction(interaction) {
  const action = interaction.customId.replace('theme_', '');
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  let profileTheme = await ProfileTheme.findOne({ userId, guildId });
  if (!profileTheme) {
    profileTheme = await ProfileTheme.create({
      userId,
      guildId,
      ownedThemes: ['default']
    });
  }
  
  if (action === 'status') {
    // Show modal for status change
    const modal = new ModalBuilder()
      .setCustomId('theme_status_modal')
      .setTitle('ƒê·ªïi Status');
    
    const statusInput = new TextInputBuilder()
      .setCustomId('status_input')
      .setLabel('Status m·ªõi:')
      .setStyle(TextInputStyle.Short)
      .setMaxLength(100)
      .setPlaceholder('ƒêang c√¢u c√°...')
      .setValue(profileTheme.showcase?.status || '');
    
    const firstActionRow = new ActionRowBuilder().addComponents(statusInput);
    modal.addComponents(firstActionRow);
    
    await interaction.showModal(modal);
  } else if (action === 'mood') {
    // Simple mood selection with buttons
    const embed = new EmbedBuilder()
      .setColor('#48dbfb')
      .setTitle('üòä Ch·ªçn Mood')
      .setDescription('Ch·ªçn mood hi·ªán t·∫°i c·ªßa b·∫°n:');
    
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId('mood_üòä').setLabel('üòä Vui').setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId('mood_üòé').setLabel('üòé Cool').setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId('mood_ü§î').setLabel('ü§î Suy nghƒ©').setStyle(ButtonStyle.Primary),
      new ButtonBuilder().setCustomId('mood_üò¥').setLabel('üò¥ Bu·ªìn ng·ªß').setStyle(ButtonStyle.Primary)
    );
    
    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId('mood_üî•').setLabel('üî• Nhi·ªát huy·∫øt').setStyle(ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId('mood_üí™').setLabel('üí™ M·∫°nh m·∫Ω').setStyle(ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId('mood_üé£').setLabel('üé£ C√¢u c√°').setStyle(ButtonStyle.Secondary),
      new ButtonBuilder().setCustomId('mood_üí∞').setLabel('üí∞ Gi√†u c√≥').setStyle(ButtonStyle.Secondary)
    );
    
    await interaction.update({ embeds: [embed], components: [row1, row2] });
  } else if (action === 'quote') {
    // Show modal for quote change
    const modal = new ModalBuilder()
      .setCustomId('theme_quote_modal')
      .setTitle('ƒê·ªïi Quote');
    
    const quoteInput = new TextInputBuilder()
      .setCustomId('quote_input')
      .setLabel('Quote m·ªõi:')
      .setStyle(TextInputStyle.Paragraph)
      .setMaxLength(200)
      .setPlaceholder('Cu·ªôc s·ªëng nh∆∞ c√¢u c√°, c·∫ßn ki√™n nh·∫´n...')
      .setValue(profileTheme.showcase?.quote || '');
    
    const firstActionRow = new ActionRowBuilder().addComponents(quoteInput);
    modal.addComponents(firstActionRow);
    
    await interaction.showModal(modal);
  }
}

// Handle mood selection
async function handleMoodSelection(interaction) {
  const mood = interaction.customId.replace('mood_', '');
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  let profileTheme = await ProfileTheme.findOne({ userId, guildId });
  if (!profileTheme) {
    profileTheme = await ProfileTheme.create({ userId, guildId });
  }
  
  profileTheme.showcase.mood = mood;
  await profileTheme.save();
  
  const embed = new EmbedBuilder()
    .setColor('#00ff00')
    .setTitle('‚úÖ Mood ƒê√£ ƒê∆∞·ª£c C·∫≠p Nh·∫≠t!')
    .setDescription(`Mood c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c ƒë·ªïi th√†nh: ${mood}`)
    .setTimestamp();
  
  await interaction.update({ embeds: [embed], components: [] });
}

// Handle modal submissions
async function handleModalSubmit(interaction) {
  const modalId = interaction.customId;
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  let profileTheme = await ProfileTheme.findOne({ userId, guildId });
  if (!profileTheme) {
    profileTheme = await ProfileTheme.create({ userId, guildId });
  }
  
  if (modalId === 'theme_status_modal') {
    const newStatus = interaction.fields.getTextInputValue('status_input');
    profileTheme.showcase.status = newStatus;
    await profileTheme.save();
    
    const embed = new EmbedBuilder()
      .setColor('#00ff00')
      .setTitle('‚úÖ Status ƒê√£ ƒê∆∞·ª£c C·∫≠p Nh·∫≠t!')
      .setDescription(`Status m·ªõi: "${newStatus}"`)
      .setTimestamp();
    
    await interaction.reply({ embeds: [embed], ephemeral: true });
  } else if (modalId === 'theme_quote_modal') {
    const newQuote = interaction.fields.getTextInputValue('quote_input');
    profileTheme.showcase.quote = newQuote;
    await profileTheme.save();
    
    const embed = new EmbedBuilder()
      .setColor('#00ff00')
      .setTitle('‚úÖ Quote ƒê√£ ƒê∆∞·ª£c C·∫≠p Nh·∫≠t!')
      .setDescription(`Quote m·ªõi: "${newQuote}"`)
      .setTimestamp();
    
    await interaction.reply({ embeds: [embed], ephemeral: true });
  } else if (modalId === 'tx_custom_amount') {
    await handleTaiXiuCustomAmount(interaction);
  } else if (modalId === 'giftcode_modal') {
    await handleGiftcodeModal(interaction);
  } else if (modalId === 'tx_custom_amount_modal') {
    // Handle custom amount modal submission
    const amountStr = interaction.fields.getTextInputValue('custom_amount_input');
    const amount = parseInt(amountStr.replace(/[^\d]/g, ''));
    
    if (isNaN(amount) || amount < 100) {
      return interaction.reply({ 
        content: 'S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá! T·ªëi thi·ªÉu 100 xu.', 
        ephemeral: true 
      });
    }
    
    const userSelection = global.taixiuSelections?.get(userId);
    if (!userSelection?.choice) {
      return interaction.reply({ 
        content: 'Vui l√≤ng ch·ªçn T√ÄI ho·∫∑c X·ªàU tr∆∞·ªõc!', 
        ephemeral: true 
      });
    }
    
    let profile = await User.findOne({ userId, guildId });
    if (!profile) profile = await User.create({ userId, guildId });
    
    // Place bet
    const bet = {
      userId,
      username: interaction.user.username,
      choice: userSelection.choice,
      amount,
      round: gameRoom.round
    };
    
    playerBets.set(betKey, bet);
    gameRoom.bets.push(bet);
    gameRoom.totalPool += amount;
    
    // Deduct money
    profile.coins = (profile.coins || 0) - amount;
    await profile.save();
    
    // Clean up selection
    global.taixiuSelections?.delete(userId);
    
    const timeLeft = Math.max(0, Math.ceil((gameRoom.endTime - Date.now()) / 1000));
    
    const embed = new EmbedBuilder()
      .setColor('#00ff00')
      .setTitle('üéâ ƒê·∫∑t C∆∞·ª£c T√πy Ch·ªânh Th√†nh C√¥ng!')
      .addFields(
        { name: 'üéØ L·ª±a ch·ªçn', value: userSelection.choice === 'tai' ? 'üî¥ T√ÄI (11-18)' : '‚ö´ X·ªàU (3-10)', inline: true },
        { name: 'üí∞ S·ªë ti·ªÅn c∆∞·ª£c', value: formatCurrency(amount), inline: true },
        { name: 'üèÜ T·ªïng pool', value: formatCurrency(gameRoom.totalPool), inline: true },
        { name: '‚è∞ Th·ªùi gian c√≤n l·∫°i', value: `${timeLeft}s`, inline: true },
        { name: 'üë• S·ªë ng∆∞·ªùi c∆∞·ª£c', value: `${gameRoom.bets.length}`, inline: true },
        { name: 'üí≥ S·ªë d∆∞ c√≤n l·∫°i', value: formatCurrency(profile.coins), inline: true }
      )
      .setFooter({ text: 'Ch√∫c b·∫°n may m·∫Øn! üçÄ' })
      .setTimestamp();
    
    await interaction.reply({ embeds: [embed], ephemeral: true });
  }
}

// TaiXiu button handler
async function handleTaiXiuAction(interaction) {
  const customId = interaction.customId;
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  const { gameRooms, playerBets } = await import('./commands/taixiu.mjs');
  
  let profile = await User.findOne({ userId, guildId });
  if (!profile) profile = await User.create({ userId, guildId });
  
  const gameRoom = gameRooms.get(guildId);
  if (!gameRoom || gameRoom.status !== 'betting') {
    return interaction.reply({ 
      content: 'Kh√¥ng th·ªÉ ƒë·∫∑t c∆∞·ª£c l√∫c n√†y!', 
      ephemeral: true 
    });
  }
  
  // Check if user already bet this round - use current round
  const betKey = `${guildId}_${userId}_${gameRoom.round}`;
  console.log(`Checking bet key: ${betKey}, Round: ${gameRoom.round}`);
  console.log(`PlayerBets size:`, playerBets.size);
  console.log(`PlayerBets has key:`, playerBets.has(betKey));
  
  if (playerBets.has(betKey)) {
    return interaction.reply({ 
      content: `B·∫°n ƒë√£ ƒë·∫∑t c∆∞·ª£c v√°n ${gameRoom.round} n√†y r·ªìi!`, 
      ephemeral: true 
    });
  }
  
  // Store user's current selection
  const userSelection = global.taixiuSelections?.get(userId) || {};
  
  if (customId.startsWith('tx_choice_')) {
    // Handle choice selection (T√ÄI/X·ªàU)
    const choice = customId.replace('tx_choice_', '');
    userSelection.choice = choice;
    
    if (!global.taixiuSelections) global.taixiuSelections = new Map();
    global.taixiuSelections.set(userId, userSelection);
    
    const embed = new EmbedBuilder()
      .setColor(choice === 'tai' ? '#ff6b6b' : '#2f3136')
      .setTitle('‚úÖ ƒê√£ Ch·ªçn')
      .setDescription(`B·∫°n ƒë√£ ch·ªçn: **${choice === 'tai' ? 'üî¥ T√ÄI (11-18)' : '‚ö´ X·ªàU (3-10)'}**\n\nB√¢y gi·ªù ch·ªçn s·ªë ti·ªÅn c∆∞·ª£c:`)
      .setFooter({ text: 'Nh·∫•n v√†o s·ªë ti·ªÅn b√™n d∆∞·ªõi ƒë·ªÉ ho√†n t·∫•t c∆∞·ª£c!' });
    
    await interaction.update({ embeds: [embed] });
    
  } else if (customId.startsWith('tx_amount_')) {
    // Handle amount selection
    if (!userSelection.choice) {
      return interaction.reply({ 
        content: 'Vui l√≤ng ch·ªçn T√ÄI ho·∫∑c X·ªàU tr∆∞·ªõc!', 
        ephemeral: true 
      });
    }
    
    let amount;
    if (customId === 'tx_amount_allin') {
      amount = profile.coins || 0;
    } else if (customId === 'tx_amount_custom') {
      // Show modal for custom amount
      const modal = new ModalBuilder()
        .setCustomId('tx_custom_amount')
        .setTitle('Nh·∫≠p S·ªë Ti·ªÅn C∆∞·ª£c');
      
      const amountInput = new TextInputBuilder()
        .setCustomId('amount_input')
        .setLabel('S·ªë ti·ªÅn c∆∞·ª£c:')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('V√≠ d·ª•: 5000')
        .setMinLength(2)
        .setMaxLength(10);
      
      const firstActionRow = new ActionRowBuilder().addComponents(amountInput);
      modal.addComponents(firstActionRow);
      
      return interaction.showModal(modal);
    } else {
      amount = parseInt(customId.replace('tx_amount_', ''));
    }
    
    if ((profile.coins || 0) < amount) {
      return interaction.reply({ 
        content: `B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ c∆∞·ª£c ${formatCurrency(amount)}!`, 
        ephemeral: true 
      });
    }
    
    if (amount < 100) {
      return interaction.reply({ 
        content: 'S·ªë ti·ªÅn c∆∞·ª£c t·ªëi thi·ªÉu l√† 100 xu!', 
        ephemeral: true 
      });
    }
    
    // Place bet
    const bet = {
      userId,
      username: interaction.user.username,
      choice: userSelection.choice,
      amount,
      round: gameRoom.round
    };
    
    playerBets.set(betKey, bet);
    gameRoom.bets.push(bet);
    gameRoom.totalPool += amount;
    
    // Deduct money
    profile.coins = (profile.coins || 0) - amount;
    await profile.save();
    
    // Clean up selection
    global.taixiuSelections?.delete(userId);
    
    const timeLeft = Math.max(0, Math.ceil((gameRoom.endTime - Date.now()) / 1000));
    
    const embed = new EmbedBuilder()
      .setColor('#00ff00')
      .setTitle('üéâ ƒê·∫∑t C∆∞·ª£c Th√†nh C√¥ng!')
      .addFields(
        { name: 'üéØ L·ª±a ch·ªçn', value: userSelection.choice === 'tai' ? 'üî¥ T√ÄI (11-18)' : '‚ö´ X·ªàU (3-10)', inline: true },
        { name: 'üí∞ S·ªë ti·ªÅn c∆∞·ª£c', value: formatCurrency(amount), inline: true },
        { name: 'üèÜ T·ªïng pool', value: formatCurrency(gameRoom.totalPool), inline: true },
        { name: '‚è∞ Th·ªùi gian c√≤n l·∫°i', value: `${timeLeft}s`, inline: true },
        { name: 'üë• S·ªë ng∆∞·ªùi c∆∞·ª£c', value: `${gameRoom.bets.length}`, inline: true },
        { name: 'üí≥ S·ªë d∆∞ c√≤n l·∫°i', value: formatCurrency(profile.coins), inline: true }
      )
      .setFooter({ text: 'Ch√∫c b·∫°n may m·∫Øn! üçÄ' })
      .setTimestamp();
    
    await interaction.update({ embeds: [embed], components: [] });
  }
}

// Unified t√†i x·ªâu actions handler
async function handleTaiXiuActions(interaction) {
  const customId = interaction.customId;
  
  if (customId === 'taixiu_analysis') {
    await handleTaiXiuAnalysis(interaction);
  } else if (customId === 'taixiu_custom') {
    await handleTaiXiuCustomPlay(interaction);
  } else if (customId.startsWith('quickbet_')) {
    await handleQuickBet(interaction);
  } else if (customId.startsWith('tx_choice_') || customId.startsWith('tx_amount_')) {
    await handleTaiXiuCustomOptions(interaction);
  } else if (customId.startsWith('final_bet_')) {
    await handleFinalBet(interaction);
  } else if (customId.startsWith('tx_')) {
    await handleTaiXiuAction(interaction);
  }
}

// Handle custom betting options (choice and amount buttons)
async function handleTaiXiuCustomOptions(interaction) {
  // Store user choice/amount temporarily
  const userId = interaction.user.id;
  const customId = interaction.customId;
  
  if (customId.startsWith('tx_choice_')) {
    const choice = customId.split('_')[2]; // 'tai' or 'xiu'
    // Store choice temporarily (you can use a Map for this)
    await interaction.reply({
      content: `‚úÖ ƒê√£ ch·ªçn **${choice.toUpperCase()}**! B√¢y gi·ªù ch·ªçn s·ªë ti·ªÅn c∆∞·ª£c.`,
      ephemeral: true
    });
  } else if (customId.startsWith('tx_amount_')) {
    const amount = customId.split('_')[2]; // amount or 'allin' or 'custom'
    
    if (amount === 'custom') {
      // Show modal for custom amount
      await showCustomAmountModal(interaction);
    } else if (amount === 'allin') {
      // Handle all-in bet
      await interaction.reply({
        content: 'üî• ALL IN ƒë∆∞·ª£c ch·ªçn! Vui l√≤ng ch·ªçn T√ÄI ho·∫∑c X·ªàU tr∆∞·ªõc.',
        ephemeral: true
      });
    } else {
      // Handle numeric amount
      await interaction.reply({
        content: `üí∞ ƒê√£ ch·ªçn ${formatCurrency(parseInt(amount))}! Vui l√≤ng ch·ªçn T√ÄI ho·∫∑c X·ªàU tr∆∞·ªõc.`,
        ephemeral: true
      });
    }
  }
}

// Show custom amount modal
async function showCustomAmountModal(interaction) {
  const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
  
  const modal = new ModalBuilder()
    .setCustomId('tx_custom_amount_modal')
    .setTitle('üí∞ Nh·∫≠p S·ªë Ti·ªÅn C∆∞·ª£c');
  
  const amountInput = new TextInputBuilder()
    .setCustomId('custom_amount_input')
    .setLabel('S·ªë ti·ªÅn c∆∞·ª£c')
    .setStyle(TextInputStyle.Short)
    .setPlaceholder('V√≠ d·ª•: 50000')
    .setRequired(true)
    .setMaxLength(10);
  
  const actionRow = new ActionRowBuilder().addComponents(amountInput);
  modal.addComponents(actionRow);
  
  await interaction.showModal(modal);
}

// Handle quick bet buttons
async function handleQuickBet(interaction) {
  const customId = interaction.customId;
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  // Parse quick bet: quickbet_tai_1000 or quickbet_xiu_1000
  const parts = customId.split('_');
  const choice = parts[1]; // 'tai' or 'xiu'
  const amount = parseInt(parts[2]); // amount
  
  const { gameRooms, playerBets } = await import('./commands/taixiu.mjs');
  
  let profile = await User.findOne({ userId, guildId });
  if (!profile) profile = await User.create({ userId, guildId });
  
  const gameRoom = gameRooms.get(guildId);
  if (!gameRoom || gameRoom.status !== 'betting') {
    return interaction.reply({ 
      content: 'Kh√¥ng th·ªÉ ƒë·∫∑t c∆∞·ª£c l√∫c n√†y!', 
      ephemeral: true 
    });
  }
  
  // Check if user already bet this round
  const betKey = `${guildId}_${userId}_${gameRoom.round}`;
  console.log(`Quick bet check - Key: ${betKey}, Round: ${gameRoom.round}`);
  console.log(`PlayerBets size:`, playerBets.size);
  console.log(`PlayerBets has key:`, playerBets.has(betKey));
  
  if (playerBets.has(betKey)) {
    return interaction.reply({ 
      content: `B·∫°n ƒë√£ ƒë·∫∑t c∆∞·ª£c v√°n ${gameRoom.round} n√†y r·ªìi!`, 
      ephemeral: true 
    });
  }
  
  if ((profile.coins || 0) < amount) {
    return interaction.reply({ 
      content: `B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ c∆∞·ª£c ${formatCurrency(amount)}!`, 
      ephemeral: true 
    });
  }
  
  // Place bet
  const bet = {
    userId,
    username: interaction.user.username,
    choice,
    amount,
    round: gameRoom.round
  };
  
  playerBets.set(betKey, bet);
  gameRoom.bets.push(bet);
  gameRoom.totalPool += amount;
  
  // Deduct money
  profile.coins = (profile.coins || 0) - amount;
  await profile.save();
  
  const timeLeft = Math.max(0, Math.ceil((gameRoom.endTime - Date.now()) / 1000));
  
  const embed = new EmbedBuilder()
    .setColor(choice === 'tai' ? '#ff6b6b' : '#2f3136')
    .setTitle('‚ö° Quick Bet Th√†nh C√¥ng!')
    .addFields(
      { name: 'üéØ L·ª±a ch·ªçn', value: choice === 'tai' ? 'üî¥ T√ÄI (11-18)' : '‚ö´ X·ªàU (3-10)', inline: true },
      { name: 'üí∞ S·ªë ti·ªÅn c∆∞·ª£c', value: formatCurrency(amount), inline: true },
      { name: '‚è∞ Th·ªùi gian c√≤n l·∫°i', value: `${timeLeft}s`, inline: true },
      { name: 'üèÜ T·ªïng pool', value: formatCurrency(gameRoom.totalPool), inline: true },
      { name: 'üë• S·ªë ng∆∞·ªùi c∆∞·ª£c', value: `${gameRoom.bets.length}`, inline: true },
      { name: 'üí≥ S·ªë d∆∞ c√≤n l·∫°i', value: formatCurrency(profile.coins), inline: true }
    )
    .setFooter({ text: 'Ch√∫c b·∫°n may m·∫Øn! üçÄ' })
    .setTimestamp();
  
  await interaction.reply({ embeds: [embed], ephemeral: true });
}

// Handle quick giftcode button
async function handleQuickGiftcode(interaction) {
  const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
  
  const modal = new ModalBuilder()
    .setCustomId('giftcode_modal')
    .setTitle('üéÅ Nh·∫≠p Giftcode');
  
  const codeInput = new TextInputBuilder()
    .setCustomId('giftcode_input')
    .setLabel('M√£ Giftcode')
    .setStyle(TextInputStyle.Short)
    .setPlaceholder('Nh·∫≠p m√£ giftcode ·ªü ƒë√¢y...')
    .setRequired(true)
    .setMaxLength(20);
  
  const actionRow = new ActionRowBuilder().addComponents(codeInput);
  modal.addComponents(actionRow);
  
  await interaction.showModal(modal);
}

// Handle giftcode modal submission
async function handleGiftcodeModal(interaction) {
  const code = interaction.fields.getTextInputValue('giftcode_input').toUpperCase();
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  const Giftcode = (await import('./models/Giftcode.mjs')).default;
  const User = (await import('./models/User.mjs')).default;
  
  // Find giftcode
  const giftcode = await Giftcode.findOne({ code, guildId, isActive: true });
  if (!giftcode) {
    return interaction.reply({
      content: '‚ùå Giftcode kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n!',
      ephemeral: true
    });
  }
  
  // Check expiration
  if (giftcode.expiresAt && giftcode.expiresAt < new Date()) {
    giftcode.isActive = false;
    await giftcode.save();
    return interaction.reply({
      content: '‚è∞ Giftcode ƒë√£ h·∫øt h·∫°n!',
      ephemeral: true
    });
  }
  
  // Check max uses
  if (giftcode.maxUses !== -1 && giftcode.currentUses >= giftcode.maxUses) {
    return interaction.reply({
      content: 'üö´ Giftcode ƒë√£ h·∫øt l∆∞·ª£t s·ª≠ d·ª•ng!',
      ephemeral: true
    });
  }
  
  // Check if user already used
  if (giftcode.oneTimePerUser && giftcode.usedBy.includes(userId)) {
    return interaction.reply({
      content: 'üîÑ B·∫°n ƒë√£ s·ª≠ d·ª•ng giftcode n√†y r·ªìi!',
      ephemeral: true
    });
  }
  
  // Get or create user profile
  let profile = await User.findOne({ userId, guildId });
  if (!profile) {
    profile = await User.create({ userId, guildId });
  }
  
  // Apply rewards
  const rewards = [];
  
  if (giftcode.rewards.coins > 0) {
    profile.coins = (profile.coins || 0) + giftcode.rewards.coins;
    rewards.push(`üí∞ ${formatCurrency(giftcode.rewards.coins)}`);
  }
  
  if (giftcode.rewards.bait > 0) {
    profile.bait = (profile.bait || 0) + giftcode.rewards.bait;
    rewards.push(`ü™± ${giftcode.rewards.bait} m·ªìi`);
  }
  
  if (giftcode.rewards.freeFishingTries > 0) {
    profile.freeFishingTries = (profile.freeFishingTries || 0) + giftcode.rewards.freeFishingTries;
    rewards.push(`üéÅ ${giftcode.rewards.freeFishingTries} l·∫ßn c√¢u mi·ªÖn ph√≠`);
  }
  
  await profile.save();
  
  // Update giftcode usage
  giftcode.currentUses += 1;
  giftcode.usedBy.push(userId);
  await giftcode.save();
  
  const { EmbedBuilder } = await import('discord.js');
  const embed = new EmbedBuilder()
    .setColor('#00ff00')
    .setTitle('üéâ Giftcode Th√†nh C√¥ng!')
    .setDescription(`**M√£: \`${code}\`**\n${giftcode.description || 'Ch√∫c m·ª´ng b·∫°n!'}`)
    .addFields({ 
      name: 'üéÅ Ph·∫ßn th∆∞·ªüng', 
      value: rewards.join('\n') || 'Kh√¥ng c√≥', 
      inline: false 
    })
    .setTimestamp();
  
  await interaction.reply({ embeds: [embed], ephemeral: true });
}

// Handle Tai Xiu custom play
async function handleTaiXiuCustomPlay(interaction) {
  const { ActionRowBuilder, ButtonBuilder, ButtonStyle, EmbedBuilder } = await import('discord.js');
  
  const embed = new EmbedBuilder()
    .setColor('#e74c3c')
    .setTitle('üéØ T√†i X·ªâu - Ch·∫ø ƒê·ªô T√πy Ch·ªânh')
    .setDescription('Ch·ªçn T√ÄI ho·∫∑c X·ªàU, sau ƒë√≥ ch·ªçn s·ªë ti·ªÅn c∆∞·ª£c')
    .addFields(
      { name: 'üî¥ T√ÄI', value: 'T·ªïng 3 x√∫c x·∫Øc t·ª´ 11-17', inline: true },
      { name: '‚ö´ X·ªàU', value: 'T·ªïng 3 x√∫c x·∫Øc t·ª´ 4-10', inline: true }
    );

  const choiceRow = new ActionRowBuilder().addComponents(
    new ButtonBuilder()
      .setCustomId('tx_choice_tai')
      .setLabel('üî¥ T√ÄI')
      .setStyle(ButtonStyle.Danger),
    new ButtonBuilder()
      .setCustomId('tx_choice_xiu')
      .setLabel('‚ö´ X·ªàU')
      .setStyle(ButtonStyle.Secondary)
  );

  const amountRow = new ActionRowBuilder().addComponents(
    new ButtonBuilder()
      .setCustomId('tx_amount_1000')
      .setLabel('üí∞ 1K')
      .setStyle(ButtonStyle.Primary),
    new ButtonBuilder()
      .setCustomId('tx_amount_5000')
      .setLabel('üí∞ 5K')
      .setStyle(ButtonStyle.Primary),
    new ButtonBuilder()
      .setCustomId('tx_amount_10000')
      .setLabel('üí∞ 10K')
      .setStyle(ButtonStyle.Primary),
    new ButtonBuilder()
      .setCustomId('tx_amount_allin')
      .setLabel('üî• ALL IN')
      .setStyle(ButtonStyle.Danger)
  );

  await interaction.reply({
    embeds: [embed],
    components: [choiceRow, amountRow],
    ephemeral: true
  });
}

// Handle t√†i x·ªâu analysis (view recent history)
async function handleTaiXiuAnalysis(interaction) {
  const guildId = interaction.guildId;
  
  const { gameRooms } = await import('./commands/taixiu.mjs');
  const gameRoom = gameRooms.get(guildId);
  
  if (!gameRoom) {
    return interaction.reply({
      content: 'Ch∆∞a c√≥ ph√≤ng game n√†o!',
      ephemeral: true
    });
  }
  
  // Get recent 10 results
  const recentResults = gameRoom.history.slice(-10);
  
  if (recentResults.length === 0) {
    return interaction.reply({
      content: 'Ch∆∞a c√≥ l·ªãch s·ª≠ ƒë·ªÉ soi c·∫ßu!',
      ephemeral: true
    });
  }
  
  const { EmbedBuilder } = await import('discord.js');
  
  // Calculate stats
  const taiCount = recentResults.filter(r => r.result === 'tai').length;
  const xiuCount = recentResults.filter(r => r.result === 'xiu').length;
  
  // Current streak
  let currentStreak = { type: 'Kh√¥ng c√≥', count: 0 };
  if (recentResults.length > 0) {
    const lastResult = recentResults[recentResults.length - 1].result;
    let streakCount = 1;
    
    for (let i = recentResults.length - 2; i >= 0; i--) {
      if (recentResults[i].result === lastResult) {
        streakCount++;
      } else {
        break;
      }
    }
    
    currentStreak = {
      type: lastResult === 'tai' ? 'T√ÄI' : 'X·ªàU',
      count: streakCount
    };
  }
  
  const embed = new EmbedBuilder()
    .setColor('#9b59b6')
    .setTitle('üîÆ Soi C·∫ßu T√†i X·ªâu')
    .setDescription(`**L·ªãch s·ª≠ ${recentResults.length} v√°n g·∫ßn nh·∫•t**`)
    .addFields(
      { name: 'üìä Th·ªëng k√™', value: `üî¥ T√ÄI: ${taiCount}/${recentResults.length} v√°n\n‚ö´ X·ªàU: ${xiuCount}/${recentResults.length} v√°n`, inline: true },
      { name: 'üî• Chu·ªói hi·ªán t·∫°i', value: `${currentStreak.type} - ${currentStreak.count} v√°n li√™n ti·∫øp`, inline: true },
      { name: 'üéØ V√°n ti·∫øp theo', value: `V√°n #${gameRoom.round}`, inline: true }
    )
    .addFields({
      name: 'üìú L·ªãch s·ª≠ chi ti·∫øt (m·ªõi ‚Üí c≈©)',
      value: recentResults.slice().reverse().map((r, i) => {
        const resultIcon = r.result === 'tai' ? 'üî¥' : '‚ö´';
        const diceEmojis = ['', '‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
        const dice = r.dice.map(d => diceEmojis[d]).join('');
        const isRecent = i < 3 ? 'üÜï' : '';
        return `**V√°n ${r.round}:** ${dice} = ${r.total} ${resultIcon} ${r.result.toUpperCase()} ${isRecent}`;
      }).join('\n'),
      inline: false
    })
    .setFooter({ text: 'D·ª±a v√†o l·ªãch s·ª≠ ƒë·ªÉ t·ª± ƒë∆∞a ra quy·∫øt ƒë·ªãnh!' })
    .setTimestamp();
  
  await interaction.reply({ 
    embeds: [embed], 
    ephemeral: true 
  });
}

// Handle final bet confirmation
async function handleFinalBet(interaction) {
  const customId = interaction.customId;
  const parts = customId.split('_'); // ['final', 'bet', 'tai/xiu', 'amount']
  const choice = parts[2];
  const amount = parseInt(parts[3]);
  
  const userId = interaction.user.id;
  const guildId = interaction.guildId;
  
  // Use the existing placeBet function logic
  const { gameRooms, playerBets } = await import('./commands/taixiu.mjs');
  const User = (await import('./models/User.mjs')).default;
  
  let profile = await User.findOne({ userId, guildId });
  if (!profile) profile = await User.create({ userId, guildId });
  
  const gameRoom = gameRooms.get(guildId);
  if (!gameRoom || gameRoom.status !== 'betting') {
    return interaction.reply({ 
      content: 'Kh√¥ng th·ªÉ ƒë·∫∑t c∆∞·ª£c l√∫c n√†y!', 
      ephemeral: true 
    });
  }
  
  // Check if user already bet this round
  const betKey = `${guildId}_${userId}_${gameRoom.round}`;
  if (playerBets.has(betKey)) {
    return interaction.reply({ 
      content: `B·∫°n ƒë√£ ƒë·∫∑t c∆∞·ª£c v√°n ${gameRoom.round} n√†y r·ªìi!`, 
      ephemeral: true 
    });
  }
  
  if ((profile.coins || 0) < amount) {
    const { formatCurrency } = await import('./commands/util.mjs');
    return interaction.reply({ 
      content: `B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ c∆∞·ª£c ${formatCurrency(amount)}!`, 
      ephemeral: true 
    });
  }
  
  // Place bet
  const bet = {
    userId,
    username: interaction.user.username,
    choice,
    amount,
    round: gameRoom.round
  };
  
  playerBets.set(betKey, bet);
  gameRoom.bets.push(bet);
  gameRoom.totalPool += amount;
  
  // Add to jackpot (5% of bet)
  const jackpotContribution = Math.floor(amount * gameRoom.settings.jackpotRate);
  gameRoom.jackpot.amount += jackpotContribution;
  gameRoom.jackpot.contributors++;
  gameRoom.jackpot.totalContributed += jackpotContribution;
  
  // Deduct money temporarily
  profile.coins = (profile.coins || 0) - amount;
  await profile.save();
  
  const { formatCurrency } = await import('./commands/util.mjs');
  const { EmbedBuilder } = await import('discord.js');
  
  const embed = new EmbedBuilder()
    .setColor('#00ff00')
    .setTitle('‚úÖ ƒê·∫∑t C∆∞·ª£c Th√†nh C√¥ng!')
    .setDescription(`**V√°n #${gameRoom.round}**`)
    .addFields(
      { name: 'üéØ L·ª±a ch·ªçn', value: choice === 'tai' ? 'üî¥ T√ÄI (11-18)' : '‚ö´ X·ªàU (3-10)', inline: true },
      { name: 'üí∞ S·ªë ti·ªÅn c∆∞·ª£c', value: formatCurrency(amount), inline: true },
      { name: 'üí≥ S·ªë d∆∞ c√≤n l·∫°i', value: formatCurrency(profile.coins), inline: true },
      { name: 'üíé G√≥p v√†o Jackpot', value: formatCurrency(jackpotContribution), inline: true },
      { name: 'üèÜ T·ªïng pool', value: formatCurrency(gameRoom.totalPool), inline: true },
      { name: 'üë• T·ªïng ng∆∞·ªùi ch∆°i', value: `${gameRoom.bets.length}`, inline: true }
    )
    .setFooter({ text: 'Ch√∫c b·∫°n may m·∫Øn!' })
    .setTimestamp();
  
  await interaction.reply({ embeds: [embed], ephemeral: true });
}
